{"meta":{"title":"前端学习笔记","subtitle":"平庸不止于平庸，巅峰不甘于巅峰","description":"","author":"WangTao","url":"https://github.com/beat-the-buzzer","root":"/"},"pages":[{"title":"categories","date":"2023-12-06T15:25:19.249Z","updated":"2023-12-06T15:25:19.249Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/beat-the-buzzer/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-12T16:37:10.000Z","updated":"2023-12-06T15:25:19.249Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/beat-the-buzzer/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"简介npm、yarn、pnpm","slug":"npm-yarn-pnpm","date":"2023-12-05T16:00:00.000Z","updated":"2023-12-06T15:25:19.246Z","comments":true,"path":"2023/12/06/npm-yarn-pnpm/","link":"","permalink":"https://github.com/beat-the-buzzer/2023/12/06/npm-yarn-pnpm/","excerpt":"","text":"npm的问题在npm@3之前安装依赖时会出现依赖之间互相嵌套，就像树结构一样一层一层，过深的层级嵌套会带来大量重复的文件，有些依赖会重复安装，占用磁盘空间。 12345678node_modules└─ a ├─ index.js ├─ package.json └─ node_modules └─ b ├─ index.js └─ package.json yarn的优化和问题Yarn引入扁平化处理依赖嵌套，也就是将所有的依赖都放在一个node_modules下，依赖在统一层级下互相引用，这样是解决了之前的一些问题，但也导致了新的问题出现就是幽灵依赖。 1234567node_modules├─ a| ├─ index.js| └─ package.json└─ b ├─ index.js └─ package.json 幽灵依赖是指项目中使用了一些没有在package.json中定义的包。比如A库依赖B库，那么这两个库都会平铺到node_modules下。如果项目中使用了B库，然后在package.json定义了进行安装，所以可以直接访问。假如某天项目不需要A库或者将A库删除，此时B库就会因为找不到A库而跑不起来。 另外，npm和yarn都有的问题是：同一台电脑，运行多个项目，需要多次安装依赖，这样会大大占用磁盘空间。 pnpm.pnpm称为虚拟存储目录，以平铺的形式储存着所有的项目依赖包，每个依赖包都可以通过.pnpm/node_modules路径找到实际位置。 12345678910node_modules├── a -&gt; ./.pnpm/a@1.0.0/node_modules/a└── .pnpm ├── b@1.0.0 │ └── node_modules │ └── b -&gt; &lt;store&gt;/b └── a@1.0.0 └── node_modules ├── a -&gt; &lt;store&gt;/foo └── b -&gt; ../../bar@1.0.0/node_modules/bar","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"工程化","slug":"工程化","permalink":"https://github.com/beat-the-buzzer/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}]},{"title":"读书笔记系列——学会提问","slug":"reading-tips-5","date":"2023-12-03T16:00:00.000Z","updated":"2023-12-06T15:25:19.247Z","comments":true,"path":"2023/12/04/reading-tips-5/","link":"","permalink":"https://github.com/beat-the-buzzer/2023/12/04/reading-tips-5/","excerpt":"","text":"书名：《学会提问》 作者： 【内容简介】 【精彩摘抄】批判性思维论题和结论理由是什么意义不明的词","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"Ctrl ACV工程师的提效之路——plop","slug":"plop","date":"2023-12-02T16:00:00.000Z","updated":"2023-12-06T15:25:19.246Z","comments":true,"path":"2023/12/03/plop/","link":"","permalink":"https://github.com/beat-the-buzzer/2023/12/03/plop/","excerpt":"","text":"作为一名业务开发熟练的 Ctrl ACV 工程师，我每天的工作就是做业务需求，基本上都是表格增删改查，都是复制一下类似的代码，然后在这个基础上进行改动。久而久之，我发现每个人的代码都自成一派，交互方式也是千奇百怪。 为了解决交互一致的问题，我们需要有一个模板，包含了增删改查、导出导出等功能，每次功能都来源于这个模板，而不是复制粘贴已有的业务代码。 示例技术框架：vben-admin。Demo 地址：https://github.com/beat-the-buzzer/plop-snippets 新建一个查询列表页，要复制三个文件：api、vue、data，也就是接口文件、Vue 页面、data 数据，然后修改引用路径、接口、字段名等等，都是 Ctrl ACV 的操作。 我们可以使用 plop，最终实现的目标就是一个命令自动生成一个页面需要的所有结构。 安装好 plop 12npm install --save-dev plopnpm install -g plop 编写模板代码： 如图，关键在于import { getList } from &#39;/@/api//Api.ts&#39;; 这一段，这里的module和name都是变量，可以用命令行输入。 配置 plopfile 1234567891011121314151617181920212223242526272829303132333435module.exports = function (plop) &#123; // controller generator plop.setGenerator(\"pages\", &#123; description: \"新建一个查询页\", prompts: [ &#123; type: \"input\", name: \"module\", message: \"输入模块名\", &#125;, &#123; type: \"input\", name: \"name\", message: \"输入功能名\", &#125;, ], actions: [ &#123; type: \"add\", path: \"src/api/&#123;&#123;module&#125;&#125;/&#123;&#123;name&#125;&#125;Api.ts\", templateFile: \"plop-templates/pages/api.ts\", &#125;, &#123; type: \"add\", path: \"src/views/&#123;&#123;module&#125;&#125;/&#123;&#123;name&#125;&#125;/index.vue\", templateFile: \"plop-templates/pages/index.vue\", &#125;, &#123; type: \"add\", path: \"src/views/&#123;&#123;module&#125;&#125;/&#123;&#123;name&#125;&#125;/data.ts\", templateFile: \"plop-templates/pages/data.ts\", &#125;, ], &#125;);&#125;; 只需要在控制台输入命令，就能自动从模板里生成代码，并且引用关系也自动写好了，减少大量的复制粘贴操作。 12plop pages manage user # 一次性输入plop pages # 根据提示输入模块名和文件夹名 输入命令之后，自动在指定位置按照模板生成了文件，并且引用关系也自动写好了： 使用代码模板不仅仅是为了提升开发效率，更重要的目的是统一交互，至少保证新页面的代码都是规范的、交互一致的，我们需要不断完善这个模板。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"提效","slug":"提效","permalink":"https://github.com/beat-the-buzzer/tags/%E6%8F%90%E6%95%88/"}]},{"title":"仿微信公众号文章内容划线技术方案研究","slug":"underline","date":"2023-06-02T16:00:00.000Z","updated":"2023-12-06T15:25:19.248Z","comments":true,"path":"2023/06/03/underline/","link":"","permalink":"https://github.com/beat-the-buzzer/2023/06/03/underline/","excerpt":"","text":"微信公众号上线了一个功能：用户可以对微信公众号内的文字进行划线，也能看到好友对同一篇文章的划线。该功能现在正在灰度中。我们思考一下如何去实现这样的功能？ 长按的文字操作栏的自定义长按选中后，禁止系统的操作控件，通知H5展示操作工具栏。 安卓：监听：onPrepareActionMode，阻止弹出系统的工具栏。监听：onActionModeStarted，通知H5展示操作工具。 IOS：监听UIMenuController的显示，通知H5弹出自定义弹窗 H5：如何确定弹窗的位置？window.getSelection()对象，可以拿到选中内容的位置信息。这样我们就可以实现一个跟随选中内容的弹窗了。 划线记录的数据是什么？记录文本位置和文本内容。 123456789101112131415161718192021// 获取文章的文本信息function getArticleText() &#123; var articleBody = $('article')[0].cloneNode(true) // 拷贝后的DOM结构 var innerText = articleBody.innerText return innerText&#125;// 获取文章选中内容的位置【该方法有缺陷，如果段落的文字一模一样，就没有办法区分位置了。建议这里给文章的段落进行编号】function getSelectionPos() &#123; var selection = window.getSelection() // 获取Selection对象 var range = selection.getRangeAt(0) // 获取Range对象 // 获取选中文本在整篇文章文本中的起始位置 var startIndex = range.startOffset var startContainer = range.startContainer var startContainerIndex = getArticleText().indexOf(startContainer.wholeText) // 当前段落相对于整体的 var endIndex = range.endOffset var endContainer = range.endContainer var endContainerIndex = getArticleText().indexOf(endContainer.wholeText) // 当前段落相对于整体的 return [startContainerIndex + startIndex, endIndex + endContainerIndex]&#125; 如何将选中的内容进行划线&amp;如何通过给定的文本位置把指定内容进行划线关键方法：document.createTreeWalker() 大概思路就是把文章的内容进行分块，文本按照DOM节点、文本节点进行分块，然后根据window.getSelection()对象拿到选中文字的位置，在我们的小分块中找到对应的内容，然后用一个类名包裹。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200function defaultGetKeyByRange(&#123; start: e, end: t &#125;) &#123; return `$&#123;e&#125;-$&#123;t&#125;`;&#125;function getKeyByRange(e) &#123; return `$&#123;e.start&#125;-$&#123;e.end&#125;`;&#125;function needFilterNode(e) &#123; return e.classList &amp;&amp; (\"IFRAME\" == e.nodeName || e.classList.contains(\"ignoreDom\") ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT;&#125;function splitRange(e) &#123; const &#123; startContainer: t, startOffset: n, endContainer: i, endOffset: A, &#125; = e, o = document.createRange(), r = getCharBottom(t, n); if (r === getCharBottom(i, A - 1)) return o.setStart(t, n), o.setEnd(i, A), [o]; &#123; const e = findRowLastChar(r, t, n, i, A); o.setStart(t, n), o.setEnd(e.node, e.offset + 1); const s = e.offset + 1 === e.node.textContent.length; return [ o, ...splitRange(&#123; startContainer: s ? e.node._next : e.node, startOffset: s ? 0 : e.offset + 1, endContainer: i, endOffset: A, &#125;), ]; &#125;&#125;function UnderlineAction(e) &#123; // 如果没有getKeyByRange方法，则使用默认方法 !e.getKeyByRange &amp;&amp; (e.getKeyByRange = defaultGetKeyByRange); let t = []; const n = &#123;&#125;, i = &#123;&#125;; // 判断节点是否为文本节点 function A(e) &#123; return \"#text\" === e.nodeName &amp;&amp; e.textContent.length; &#125; // 在指定范围内插入下划线 function insertSpanInRange(i, A, o, r = !1) &#123; const s = []; function a(n, i, A, o) &#123; const r = n.textContent.slice(0, i), a = n.textContent.slice(i, A), l = n.textContent.slice(A), c = n.splitText(i), d = document.createDocumentFragment(), p = (function (t, n) &#123; const i = document.createElement(e.tag || \"span\"); return ( (i.textContent = t), (i.className = \"underline\"), s.push(i), Object.keys(n).forEach((e) =&gt; (i[e] = n[e])), i ); &#125;)(a, o), m = p.childNodes[0]; // 将下划线的位置添加到t数组中 if ( (t.fill(m, n._wordoffset + i, n._wordoffset + A), (m._wordoffset = n._wordoffset + i), d.appendChild(p), l) ) &#123; const e = document.createTextNode(l); (m._next = e), (e._prev = m), (e._wordoffset = n._wordoffset + A), n._next ? ((e._next = n._next), (n._next._prev = e), t.fill(e, n._wordoffset + A, n._next._wordoffset)) : t.fill(e, n._wordoffset + A), d.appendChild(e); &#125; else n._next &amp;&amp; ((m._next = n._next), (n._next._prev = m)); // 将下划线添加到文本节点中 return ( r ? ((n._next = m), (m._prev = n)) : (n._prev &amp;&amp; ((n._prev._next = m), (m._prev = n._prev)), n.remove()), c.parentNode.insertBefore(d, c), c.remove(), m ); &#125; try &#123; if (A &lt;= i) return; const l = e.getKeyByRange(&#123; start: i, end: A, props: o &#125;), c = t[i], d = t[A - 1]; if (!c || !d) return; let p = c; if (c === d) a(p, i - p._wordoffset, A - p._wordoffset, &#123; ...o, underlineKey: l &#125;); else do &#123; if (p === c) p = a(p, i - p._wordoffset, p.textContent.length, &#123; ...o, underlineKey: l, &#125;); else &#123; if (p === d) &#123; p = a(p, 0, A - p._wordoffset, &#123; ...o, underlineKey: l &#125;); break; &#125; p = a(p, 0, p.textContent.length, &#123; ...o, underlineKey: l &#125;); &#125; p = p._next; &#125; while (p); // 将下划线的位置添加到n或i对象中 return r ? s : ((n[l] = s), l); &#125; catch (l) &#123; console.error(l); &#125; &#125; function r(e) &#123; const n = e.parentNode; let i, o; for (; (i = e.childNodes[0]);) n.insertBefore(i, e); e.remove(), n.childNodes.forEach((e) =&gt; &#123; A(e) ? (o || (o = e), t.fill(o, e._wordoffset, e._wordoffset + e.textContent.length), e._next &amp;&amp; (e._next._prev = o), (o._next = e._next)) : (o = null); &#125;), n.normalize(); &#125; function removeSpanByKey(e, t = !1) &#123; t ? i[e] &amp;&amp; (i[e].forEach((e) =&gt; e.remove()), delete i[e]) : n[e] &amp;&amp; (n[e].forEach(r), delete n[e]); &#125; function getSpanByKey(e, t = !1) &#123; return t ? i[e] || [] : n[e] || []; &#125; /** * 该函数用于获取文本节点数组 * @returns &#123;Array&#125; 返回文本节点数组 */ function l() &#123; console.log('看看这一行') t = []; const n = \"string\" == typeof e.selector ? document.querySelector(e.selector) : e.selector; if (!n) return; let i = 0, o = null; const r = document.createTreeWalker( n, NodeFilter.SHOW_ALL, &#123; acceptNode: e.needFilterNode || (() =&gt; NodeFilter.FILTER_ACCEPT) &#125;, !0 ); let s = r.currentNode; for (; s;) &#123; if (((s._wordoffset = i), A(s))) &#123; o &amp;&amp; ((o._next = s), (s._prev = o)); const e = i + s.textContent.length; (t.length = e), t.fill(s, i, e), (i = e), (o = s); &#125; s = r.nextNode(); &#125; window.t = t console.log(\"t\", t) // 分块的内容 return t; &#125; return ( l(), &#123; insertSpanInRange: insertSpanInRange, removeSpanByKey: removeSpanByKey, getSpanByKey: getSpanByKey &#125; )&#125;window.underlineAction = UnderlineAction(&#123; selector: 'article', getKeyByRange: getKeyByRange, needFilterNode: needFilterNode&#125;) 如果文本内容发生了改变，已经记录的划线的位置该如何处理？把改动的细节上报给服务端，服务端去更新已经记录的划线数据。 123456789101112131415161718192021222324// 生成文本对比工具const JsDiff = require('diff')function compareText(text1, text2) &#123; const diff = JsDiff.diffChars(text1, text2) let index = 0 // 添加计数器变量 const newDiff = [] diff.forEach(part =&gt; &#123; part.index = text1.indexOf(part.value, index) // 添加 part 在 text1 中的索引 if(part.added || part.removed) &#123; part.index = index newDiff.push(part) &#125; else &#123; index = part.index + part.value.length // 更新计数器变量 &#125; &#125;) return newDiff // 返回索引数组&#125;// 测试const text1 = 'Hello, world!';const text2 = 'Hello, JavaScript!';const comparedText = compareText(text1, text2)console.log(comparedText) 1// 输出内容 根据我们已划线的位置和内容的变化，我们最终计算出新的文本里的划线位置。","categories":[{"name":"技术方案","slug":"技术方案","permalink":"https://github.com/beat-the-buzzer/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"}]},{"title":"iOS微信自动播放视频的处理方案","slug":"IOS-wechat-play-video","date":"2023-04-04T16:00:00.000Z","updated":"2023-12-06T15:25:19.242Z","comments":true,"path":"2023/04/05/IOS-wechat-play-video/","link":"","permalink":"https://github.com/beat-the-buzzer/2023/04/05/IOS-wechat-play-video/","excerpt":"","text":"iOS微信自动播放视频的处理方案现象：iOS的微信会阻止视频和音频的加载，因此我们设置的autoplay属性是不会生效的，并且在iOS微信上，视频的duration也不会被加载出来。 处理方式： 123456789101112131415161718192021222324252627document.addEventListener('WeixinJSBridgeReady', play, false)function play() &#123; // 如果视频出现在视口内，并且设置了自动播放，就去执行播放操作 if (isElementInView(videoDom) &amp;&amp; autoplay) &#123; const promise = videoDom.play() // 返回一个Promise if (promise != undefined) &#123; promise .then(() =&gt; &#123; videoDom.play() &#125;) .catch(error =&gt; &#123; videoDom.muted = false; &#125;) &#125; &#125;&#125;function isElementInView() &#123; const rect = el.getBoundingClientRect() const inView = rect.top &gt;= 0 &amp;&amp; rect.left &gt;= 0 &amp;&amp; rect.bottom &lt;= (window.innerHeight || document.documentElement.clientHeight) &amp;&amp; rect.right &lt;= (window.innerWidth || document.documentElement.clientWidth) return inView&#125; 这种方式可以成功的两个重要原理： WeixinJSBridgeReady和用户的真实操作来（touchend、click、doubleclick 或 keydown 事件等标准的事件）触发调用video.play()，才能自动播放视频。 video.play()是一个异步操作，返回一个Promise，并不是一个瞬时的操作。因此，一个src为空的video触发了play，会等到src赋值正确之后再去进行播放。 最终页面的加载流程： video的Dom结构渲染 ===&gt; 监听weixinJsBridgeReady ===&gt; 触发weixinJsBridgeReady，执行video的play ===&gt; 拿到video的src，进行赋值 ===&gt; 播放","categories":[{"name":"疑难问题","slug":"疑难问题","permalink":"https://github.com/beat-the-buzzer/categories/%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/"}],"tags":[{"name":"疑难问题","slug":"疑难问题","permalink":"https://github.com/beat-the-buzzer/tags/%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/"},{"name":"视频","slug":"视频","permalink":"https://github.com/beat-the-buzzer/tags/%E8%A7%86%E9%A2%91/"}]},{"title":"幸存者偏差","slug":"laws/survivorship-bias","date":"2023-01-29T16:00:00.000Z","updated":"2023-12-06T15:25:19.246Z","comments":true,"path":"2023/01/30/laws/survivorship-bias/","link":"","permalink":"https://github.com/beat-the-buzzer/2023/01/30/laws/survivorship-bias/","excerpt":"","text":"“幸存者偏差”，是一种以偏概全的思维方式。就字面意思而言，“幸存者偏差”是指在收集信息的时候，只关注幸存者，而忽略死者，因为“死人是不会说话的”，这就会导致收集的信息不全面，进而使得出的结论与实际情况存在偏差。从心理学上讲，“幸存者偏差”是一种比较常见的逻辑谬误，是指通过某些经过筛选的信息得出结论，而没有意识到筛选的过程，也没有意识到被筛选掉的关键信息。 飞机防护案例二战期间，美国军方研究返航的战斗机的损毁情况后，发现这些战斗机都是机翼中弹，所以得出加固机翼的结论。但哥伦比亚大学统计学教授沃德指出，要想救飞行员的性命，更正确的方法是去研究那些被打中并坠毁的飞机。 读书无用论很多人得出“读书无用”的结论，是因为看到有些人“没有好好上学却仍然当老板、赚大钱”，却忽略了那些因为没有好好上学而默默无闻，甚至失魂落魄的人。 如何应对 建立“概率论”思维。“概率论”告诉大家，在一段较长的时间内，一个事物的表现会趋于平均水平，即“均值回归”，根据这个理论，大家在做判断的时候应该避免盯着某些“小概率事件”不放，而要从更宏观、客观的角度思考问题。 避免陷入“简单逻辑”。研究证明，因为大脑每天都要处理很多信息，所以其更喜欢按照简单、省力的方式来运作，而“简单逻辑”便是一个人在面对某件事情时，不假思索就能出现的思维方式。但必须明确的是，“简单逻辑”有一定的好处，比如可以节约精力等，但有时候也可能会让人做出错误的判断，因此，在处理问题的时候，不妨多问自己一个为什么，多和别人进行一次交流。 学会拆分任务。“幸存者偏差”等逻辑谬误之所以会出现，一个很重要的原因是人们习惯于关注现存的、眼前的事物，即更相信“眼见为实”，而忽略某些隐藏信息和细节。对此，大家可以通过拆分任务的方式，让自己对任务更加明确，比如在制定目标的时候，可以将大目标拆分成一个个小目标；在完成任务的时候，可以将大任务拆分成一个个具体的步骤。 参考文献：http://lxjk.people.cn/n1/2018/0608/c404177-30046770.html","categories":[{"name":"定律","slug":"定律","permalink":"https://github.com/beat-the-buzzer/categories/%E5%AE%9A%E5%BE%8B/"}],"tags":[{"name":"心理学","slug":"心理学","permalink":"https://github.com/beat-the-buzzer/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"认知","slug":"认知","permalink":"https://github.com/beat-the-buzzer/tags/%E8%AE%A4%E7%9F%A5/"}]},{"title":"网络三定律","slug":"laws/IT-3-laws","date":"2023-01-29T16:00:00.000Z","updated":"2023-12-06T15:25:19.246Z","comments":true,"path":"2023/01/30/laws/IT-3-laws/","link":"","permalink":"https://github.com/beat-the-buzzer/2023/01/30/laws/IT-3-laws/","excerpt":"","text":"摩尔定律——揭示信息技术进步速度 集成电路上可以容纳的晶体管数目在大约每经过18个月到24个月便会增加一倍。 吉尔德定律 也叫胜利者浪费定律 ，由乔治·吉尔德提出，最为成功的商业运作模式是价格最低的资源将会被尽可能的消耗，以此来保存最昂贵的资源。 麦特卡夫定律 网络价值同网络用户数量的平方成正比，即 N 个联结能创造 N 的2次方效益。如果将机器联成一个网络，在网络上，每一个人都可以看到所有其他人的内容，100人每人能看到100人的内容，所以效率是 10的4次方 。10 的4次方人的效率就是 10的8次方 。","categories":[{"name":"定律","slug":"定律","permalink":"https://github.com/beat-the-buzzer/categories/%E5%AE%9A%E5%BE%8B/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://github.com/beat-the-buzzer/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"GitHub SSH认证","slug":"git-auth","date":"2022-06-01T15:59:03.000Z","updated":"2023-12-06T15:25:19.244Z","comments":true,"path":"2022/06/01/git-auth/","link":"","permalink":"https://github.com/beat-the-buzzer/2022/06/01/git-auth/","excerpt":"","text":"GitHub提交代码现在需要密钥。 参考","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://github.com/beat-the-buzzer/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://github.com/beat-the-buzzer/tags/GitHub/"}]},{"title":"Command API","slug":"command-api","date":"2022-02-19T16:00:00.000Z","updated":"2023-12-06T15:25:19.243Z","comments":true,"path":"2022/02/20/command-api/","link":"","permalink":"https://github.com/beat-the-buzzer/2022/02/20/command-api/","excerpt":"","text":"最近在浏览器上调试的时候，无意中使用了JQuery的一些语句，但是在我的项目中没有引用过JQuery。然后在代码里使用$(&#39;body&#39;)是会报错的","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","permalink":"https://github.com/beat-the-buzzer/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"MQTT介绍：简单的实时通讯功能（web端）","slug":"mqtt","date":"2022-02-05T16:00:00.000Z","updated":"2023-12-06T15:25:19.246Z","comments":true,"path":"2022/02/06/mqtt/","link":"","permalink":"https://github.com/beat-the-buzzer/2022/02/06/mqtt/","excerpt":"","text":"MQTT是一个轻量级的发布/订阅消息传输协议。MQTT协议是轻量、简单、开放和易于实现的，这些特点使它适用范围非常广泛。 如何接入MQTT？ 一般我们通过paho.mqtt来接入MQTT。 服务端定义消息的结构： 1234567message Message &#123; required uint64 message_id = 1; required uint64 sender_id = 2; required string content = 3; required uint64 create_time = 4; required uint64 receiver_id = 5;&#125; 我们可以把服务端定义的消息结构编译成JS，这样就能够在web端解析消息了。 如何编译？ 1protoc --js_out=import_style=commonjs,binary:./ messages.proto 12345678910111213message ServiceMessage &#123; required uint64 message_id = 1 [jstype = JS_STRING]; // 解决js丢失大数字精度问题 required uint64 user_id = 2; required ServiceType service_type = 3; required MessageType message_type = 4; required string content = 5; required uint64 create_date = 6; required ServiceMessageDirection direction = 7; optional uint64 agent_id = 8; optional uint32 post_proc = 9; optional uint32 to_reply = 10; optional string extend = 11;&#125; 注意长数字的转换，会有精度丢失的问题。因为前端的大数字会丢失精度，所以需要在编译的时候将其转成字符串。 引用 paho_mqtt.js： 引用 paho_mqtt.js 12345678910111213141516171819202122232425262728293031323334353637import sendMessage from './msg_pb.js'import Paho from './paho-mqtt.js'// MQTT的连接this.client = new Paho.MQTT.Client(HOSTNAME, PORT, CLIENTID)this.client.onConnectionLost = this.onConnectionLost // 注册连接断开处理事件this.client.onMessageArrived = this.onMessageArrived // 注册消息接收处理事件this.client.onMessageDelivered = this.onMessageDelivered // 发送消息成功之后的回调函数onConnectionLost(msg) &#123; // 重连的逻辑&#125;onMessageArrived(msg) &#123; // 消息接收的逻辑 let message = sendMessage.BaseUserUnreadStatics.deserializeBinary(msg.payloadBytes) let protoBuf = message.toObject() // 解析出来的消息&#125;onMessageDelivered(msg) &#123; // 消息发送成功之后&#125;// 发送消息sendMsg() &#123; let message = new sendMessage.Message() message.setMessageId('xxx') message.setSenderId('xxx') message.setContent('xxx') message.setCreateTime('xxx') message.setReceiverId('xxx') let bytes = message.serializeBinary() // 序列化 let msgSend = new Paho.MQTT.Message((bytes)) msgSend.topic = 'xx' this.client.send(msgSend) &#125; 实时通讯遇到的问题（技术+业务） 消息发送和接收的时间有误差，导致消息的顺序不正确。 业务：我们需要实时记录未回复的消息。无法准确评判未回复的通讯对象： 按照服务端接收消息的顺序 按照客户端接收消息的顺序 HTTP请求和TCP的消息有一个时间差。 12:00:00的时候，调用接口获取聊天记录 12:00:01的时候，对方发送了一条消息 12:00:02的时候，获取聊天记录的接口回来了 此时对方在12:00:01发送的消息就不在消息列表中。 消息回执的处理 Qos级别设置为1或2的时候，服务端在接受到消息之后，会发送一条回执消息给用户，用于标识消息已成功发送。我们在mqtt源码里，能找到对应的对消息回执的处理，一般服务端会把消息的id回填过来，需要我们去解析数据： 12case PUBACK: // ... 根据服务端定义的消息的位数（一般是16位或者64位），调用不同的解析方法： 12345678910111213// 解析16位数据function readUint16(buffer, offset) &#123; return 256 * buffer[offset] + buffer[offset + 1]&#125;// 解析64位数据：注意如果使用number类型，数据会越界，使用bigInt再将其转成字符串function readUint64(buffer, offset) &#123; const uint64 = buffer.slice(offset, offset + 8) const uint64Array = new Uint8Array(uint64) const hexString = Array.from(uint64Array, (byte) =&gt; ('0' + byte.toString(16)).slice(-2)).join('') const uint64Str = BigInt(`0x$&#123;hexString&#125;`).toString() return uint64Str&#125; 开发建议： 将聊天记录记录在本地，下次进入页面无需调用聊天记录接口（类似QQ、微信的做法） 实时记录未回复的消息，需要给消息新增回执，即对方已经收到消息的标志。类似于钉钉的消息是否已读的功能。","categories":[{"name":"通信","slug":"通信","permalink":"https://github.com/beat-the-buzzer/categories/%E9%80%9A%E4%BF%A1/"}],"tags":[{"name":"通信","slug":"通信","permalink":"https://github.com/beat-the-buzzer/tags/%E9%80%9A%E4%BF%A1/"}]},{"title":"VSCode装机必备的插件(二）","slug":"vscode-plugins-v2","date":"2022-01-03T16:00:00.000Z","updated":"2023-12-06T15:25:19.248Z","comments":true,"path":"2022/01/04/vscode-plugins-v2/","link":"","permalink":"https://github.com/beat-the-buzzer/2022/01/04/vscode-plugins-v2/","excerpt":"","text":"Git History对每次提交的变化、提交人、提交时间等等做个可视化的展示，就相当于我们使用git log命令打印出提交日志一样，这个插件可以让提交日志更好地展示出来。 GitLensGit提交信息精确到行，可以看到每一行是谁提交的。这里要注意：慎重代码格式化，否则整个文件的修改人都是你了。 KoroFileHeader 在VSCode中生成文件头部注释和函数注释，可以看到文件是在何时，由何人进行了修改。 To Be Continued!","categories":[{"name":"其他","slug":"其他","permalink":"https://github.com/beat-the-buzzer/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://github.com/beat-the-buzzer/tags/VSCode/"}]},{"title":"读书笔记系列——全职高手","slug":"reading-tips-4","date":"2021-04-17T16:00:00.000Z","updated":"2023-12-06T15:25:19.247Z","comments":true,"path":"2021/04/18/reading-tips-4/","link":"","permalink":"https://github.com/beat-the-buzzer/2021/04/18/reading-tips-4/","excerpt":"","text":"点击下载读书笔记的PDF 书名：《全职高手》 作者：蝴蝶蓝 【内容简介】 网游荣耀中被誉为教科书级别的顶尖高手叶修，因为种种原因遭到俱乐部的驱逐，离开职业圈的他栖身于一家网吧成了一个小小的网管，但是，拥有十年游戏经验的他，在荣耀新开的第十区重新投入了游戏，带着对往昔的会议，和一把未完成的自制银武器千机伞，开始了重返巅峰之路。 【精彩摘抄】 如果喜欢，就把这一切当做是荣耀，而不是炫耀。 攻略只是前人总结的经验而已，里面所写的东西只代表当下。一篇攻略，过上一年两年，甚至几个月内就会有人发现比攻略中更好的方案。这不仅仅是游戏更新的缘故，更重要的是玩家的技术水平在不断地提高进步。记录这种东西就是为了被打破而存在的，巅峰永远是存在于未来而不是过去。攻略只是参考，不应该一味参照，那样是没法取得进一步突破的。 君莫笑有能力刷出这个副本记录，他又为什么不去刷？系统设定出来这个竞争，可不就是让人去刷去竞争的吗？因为大公会需要这个记录来证明自己的实力，所以就不许君莫笑去杀？这又是一个多么可笑的逻辑。 你也是职业选手。 他的行为在针对的掩盖下，藏着的是恐惧、认可和信赖。因为害怕，他要跑去刺探对方的情况；因为认可，他偷回对方的打法就直接使用，因为他相信对方的打法已经是最佳的选择，不会有更优秀的战术。 是谁是谁是谁？跑什么，一堆33级的，连我一个27级的小剑客都怕吗？我要是垃圾，你们是不是连垃圾都不如？垃圾都不如的是什么，是不可回收的垃圾，完全没有利用价值的废弃物！没错，就是正在逃跑的你们！1、2、3、4、5、6、7、8、9、10、11、12、13、14，14坨垃圾，跑得很整齐啊！排队求回收吗？但你们忘了你们是不能回收的吗？有点觉悟，挖个坑把自己埋了吧！不要再继续污染环境了，你们存在的每一秒钟…… 想要提高自己的话，这些单调乏味的练习是免不了的。道理就是如此。 不要试图在高速攻击过程中去避免失误。可以先慢一慢，保证没有失误，然后再尝试性地提高手速，循序渐进，不要急。 机会是留给有准备的人的，而他呢？此时根本就还没有准备好，就急着去想去抓住一些看起来不错的机会，结果自然只能是跌得头破血流。 我的终点完不完美，由我自己决定。 太弱的，会被轻视；太强的，会被排挤。只有档次差不多的，才能真正的和谐与共。 只有拥有了绝对的自信，才有可能在那种推翻过去一切努力的打击后，轻松从容地说出这样一句话。而这，还不过是个十几岁的少年。 那还不是因为老夫一见你就发现你这家伙獐头鼠目贼眉鼠眼，以我街头的眼光一眼就看出你周身上下弥漫着犯罪分子的气质。这要不让你拿个冠军指不定你这变态会因此产生报复心理给社会安定团结制造极大的负担，所以为了国家为了人民，我也只好忍痛放水，让你这混蛋拿了联盟的冠军，而且一拿就是三次，这才制止了无数的悲剧。看来现在你也长大了，懂事了，老夫也不用你报答，过来给爷磕一个聊表一下寸心吧！ 坦白说，我们为之奋斗的东西，其实是很私人的理想，没有谁是为了取悦任何人才会这么做的。在取悦着你们的，只是联盟而已，我想你不要太会错意。你们的支持、鼓励，我们当然很感激，也会很感动，但是还是要很无情地说一句：为了你们在打比赛，这话有点假，至少对于我来说，完全不是。 小记者看起来人还蛮老实的，不然冲你撞伤我们老板，起码下你一条大腿。 他们这些玩战术的心都脏。 是啊！职业选手，都不应该喝酒的。 因为这一场比赛，我们准备了足足一年。 机会留给有准备的人。这道理老在说，谁都会说。但是当人人都有准备的时候，机会给谁呢？自然就是更有准备的那一个。 “我懂了，怪不得队长经常强调手速要收放自如的问题。”卢瀚文说。“哈哈哈，因为他不需要面对这一难题啊！”黄少天说。 在保席的基础上，力争总冠军吧！ 做不到，我就退出职业圈。 选择有时候无关对错，就看你有没有毅力去执行。 这些人，永远把自己摆在道德的至高点上，随意对别人指手划脚，好像不符合他们意志的做法，就一定是错的一样。他们此时个个说得好像都是为了唐柔好一般，但常先很清楚，他们无非是想看到唐柔难堪，想看到这个强硬的选手在他们面前低头而已，以此表现他们话语权的权威。 需要严肃批评的，是之后两位上场选手，两个人，却没有拿下对方一人？尤其是第三顺位出场的守擂大将方锐，战队花这么多钱把你弄来，是让你当废物点心的吗？连个王杰希都搞不定？ 别在里面绕了，直接外面见，我们赶时间。 “放心吧！”魏琛说着，“我是一定会偷袭你的。” 我去，你敢不敢不用治疗？破技能回又回不了多少血除非关键时刻的一下瞬发其他时候你以为有用吗有用吗？我以为我这一剑劈上去伤害是多少啊？完全忽略不计你那点治疗你知道吗？你就不能专注一下攻击不要做这些杂七杂八的事情破坏比赛质量拉低对决的经典程度啊？ 因为他是队长，他的肩上有着比其他人更多的职责和义务。他这个刺客，注定了不能是一个孤单行走的杀手，因为他代表的首先并不是他自己，而是一整支战队。 冠军，并不单单只是美丽和荣耀，还很残酷。得到它的，得不到它的，都出付出很多很多。 有趣？什么是有趣？热血豪迈地正面碰撞，激烈刺激的手速狂飙就叫有趣？那只是你们观众的定义罢了。对于每一个职业选手来说，他们所选择的战斗方式，就是他们认为最有趣的。或许也会有一些人，会刻意打成取悦观众的风格，这大概是这个圈子经历商业推广后所形成的风气。 如果他们当你是榜样，而不是靠山的话。 这可是有黄少天的比赛啊！现在是开场阶段又不用交手，公共频道里怎么会没有消息？啊！都已经过去七秒了，还是一条消息也没有！这是怎么回事？不会是出事了吧？比赛席里发生什么问题了吗？难道黄少天突然晕倒了？有没有人去看看啊！ 失误这种东西，你怎么在意也无法完全避免的，反倒有可能让自己在比赛中崩得过紧。放轻松，只要集中精神，追求胜利，尽最大努力做到最好，保持这样的信念就行了。不要太在意失误这种细节。 这就好比考试，有些人是有能力考100分的，但经常因为这样那样的疏忽，最终只得了90分；而罗辑，就是一个只能考90分的人，而最后，他考出的成绩就是90分。如此一来，他的实际表现，和那些有能力考100最终却考出90分的人可就完全没有区别了。 荣耀，只会属于那些看重它的人。 这是喻文州的风格，也是蓝雨战队的战术风格，自从他们战队不可或缺的灵魂人物，前队长魏琛退役以后，蓝雨就走上了崛起之路…… 我可是一个看着自己队友一个个都被杀死也能隐忍不动的耐心高手！ 能让喻文州站到如此高度，没有万分之一是因为他的缺陷，而是他为了弥补缺陷，在其他方面所做出的努力，所体现出的才能。 再怎么精彩，也不过是避开了一次攻击而已。 冠军只有一个，这很残酷；但是，却每年都有一个，这，是永不停歇的希望。 每一个失败者，最终似乎都非得再经历一轮深深地抹黑，好像不这样就不足以映衬他们失败者的身份似的。 对于被冷落，乔一帆没有什么怨恨；但是对被重视，他肝脑涂地。 你远比自己想象的要出色！ 目光不要局限在这一个对手身上，你的对手会有很多。向他学，目的不是单纯地为了战胜他，而是为了让你继续提高，收获更多的胜利。 只是很遗憾，每一次都不可能让所有人收获所期待的结果，每一次总会有人在中途就黯然退场。 在这个赛场上，努力是最不值得拿出来夸口的东西，因为这只是基本，是人人都会做到的，是最底层最渺小的东西。搞清楚这一点，再向高处攀登吧！ 人生的路可是很长的…… 我可是职业选手。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"面试总结","slug":"interview-conclusion","date":"2021-03-22T16:00:00.000Z","updated":"2023-12-06T15:25:19.245Z","comments":true,"path":"2021/03/23/interview-conclusion/","link":"","permalink":"https://github.com/beat-the-buzzer/2021/03/23/interview-conclusion/","excerpt":"","text":"经过一周多的时间的面试，工作方面终于是尘埃落定，下面就简单总结一下今年面试的情况和经验。 简历的亮点简历中的亮点是十分重要的，它直接决定面试官是否有话可问，也直接反应了最近几年我们的工作质量。如果每天都仅仅是完成自己的开发任务，我觉得是远远不够的。 我记得两年之前我的简历亮点是：阅读过XXX框架的源码，但是很多相关的问题在实际面试的时候没有回答出来，导致所谓的“亮点”起到了反作用。 今年的面试，简历里的亮点的主要有这几个，也是受到提问最多的几点： 带领团队进行 Code Review Code Review，这个是确实存在的，只不过没有我回答得那么深，但是也差不了多少。我主要是从三个层面回答这个问题： 对于提交规范的检查，因为很多人喜欢在提交代码的时候，非常随意地把一天写的代码一股脑提交上去，这样在后面定位问题的时候，很难找到我们修改的部分。因此，我们制定了一个规范，就是每次提交的时候，按bug单号提交修改的部分，提交信息包括修改的bug单号、修复的版本号、修改内容。后续有面试官提出，可以写一个Git的钩子，让机器去检查。不过后来我也想过，如果是机器检查，也很难完全查出来规范。 对于代码书写规范的检查，这个一般都是使用ESLint工具进行检查，我后面加了一点内容，就是把这个规范放到自动化编译平台上面去，这样每次打包的时候，如果代码不符合规范，就会打包出错。事实上，我的第一家公司就是这么操作的。 对于代码文档、注释方面的规范，这个是需要把每个人写的代码投影出来，主要检查一些方法的注释是否规范，一些复杂的业务逻辑是否画了流程图，一些需求文档的地址是否写在README里面，等等。 这个问题我个人觉得自己的发挥还是不错的，算是一个加分项。 负责维护前端组件库 是否是从零开始开发 开发一个公共组件的思路和注意事项 事实上，我不太清楚面试官问的重点和目的在哪 负责招聘面试 面试的时候主要关注哪些点 这个只有少部分的面试官问到了这个问题 基础知识的掌握 闭包以及闭包的作用 直到这次面试官问这个问题之前，我都不是很确定这个问题到底要如何回答。这次面试官问了这个问题之后，我又查了一些资料，进行了更深层次的理解，终于有所收获。 关于闭包，网上有一句话值得我深思：如果你觉得一个概念很难理解，那一定是因为你理解错了。 JS有哪些数据类型，如何进行类型判断 这个问题基本上都是必考题或者基础题，一旦出错，基本上就要告别这次面试了。 后来问了一个Object.prototype.toString.call 这个方法判断数据类型的原理是什么，这个打得我措手不及。 为什么数字、字符串可以像对象那样去访问属性或者调用方法？ 包装对象，貌似《你不知道的JavaScript》中有这个概念 普通函数和箭头函数有什么区别 this指向 后来补充一个，arguments对象 一些代码题 深拷贝和浅拷贝，以及如何实现一个深拷贝 貌似第一场就问到了这个问题，但是当时我没有任何准备，所以惨败。后来仔细地看了相关方案，发现没有我想象中那么简单。其实不仅仅是要解决问题，更是要说好问题出现的原因和解决问题的过程。 例如，我们平时工作中，可能就只是简单地先stringify再parse，就可以解决项目中99.99%的问题，但是作为面试题，不能仅仅这么回答就完了，我们需要一步一步朝着完美方案去靠近。比如，我们之前的方案，一些特殊类型的数据，例如数组、日期，就会在转换的时候就会出问题，为了解决这个问题，我们需要换个思路，比如使用遍历对象的方式，如果待遍历的数据是个对象，就递归调用这个方法，否则，就把这个属性进行赋值操作。其实递归调用一般我们也都能想到，但是还有一个问题就是循环引用，比如对象的一个属性值是这个原始对象本身，我们如果不处理这样的情况，就会出现递归死循环的情况，所以我们需要一个空间，把拷贝过的对象存起来，每次拷贝对象之前，看看这个对象有没有存过，可以使用ES6的Map或者WeakMap。 其实面试官在问我深拷贝之前，还问了ES6的Map数据结构，没想到这两个问题是有一定联系的。 flat 数组扁平化 这个问题在一次视频面试中被要求现场手写代码，当时也没有看，所以又惨败。 其实实现的思想就是递归，不过也有其他的思路，比如转成字符串，然后把所有的方括号都清除，然后再在左右拼接一个括号，再转成数组。 数组去重的思路 这个问题我有特意准备过，因为之前的公司有一道笔试题就是这个。当时大多数人都写了用ES6的Set去进行转换，但是我觉得这应该是个算法题，不是方法题。 Set 数据结构 循环数组，把数组push到一个临时数组里，push之前需要判断一下当前数据是否已经存在于临时数组里 循环数组，判断每一项第一次出现的位置是否等于当前的位置，如果不等于，就需要剔除这条数据。 利用对象的key是唯一的这个特性，把数组的每一项都变成一个空对象的key，但是这种方式也有局限性，就是对象的key只能是字符串，因此我们为了解决这个问题，需要去使用ES6的Map数据结构，使得其他类型的数据也可以作为Map的key，并且是唯一的，这样就实现了去重。 CSS 实现子元素相对于父元素水平垂直居中 这个也是我平时喜欢问的问题，所以就没有问题。 这一类题目，只能平时慢慢积累了。 常用框架相关 typeof JQuery/Vue/React 分别是什么 这个是我遇到的最特别的问题，通过JQuery和Vue的使用方式，我知道它们的写法是和函数一样的，所以知道这两个是function，但是React我不是很确定。根据用法，我们一般都是写React.Component，所以应该是object。 然后还问了一个class A{}，然后typeof A，我也不是很确定，最终尝试一下，是function，后来编译了一下class，最后确实是个function。 双向绑定和单项数据流 其实对这两个的概念我一直都很模糊，直到有个面试官解答了这个问题。 双向绑定和单项数据流，是两个不同的概念。 Vue、React中都有单项数据流，就是改变数据或者调用setState的时候，DOM也会跟着去更新。 双向绑定，拿Vue来说，就是Vue提供了一个语法糖，用v-model的写法，使得我们在输入的时候，改变了DOM，同时也改变了数据，本质上，我们可以使用oninput去监听输入然后进行赋值操作。后来问到如果我们不想用oninput，要怎么做，这个因为平时我对此没有什么了解，所以惨败。 工程化 Webpack相关 webpack里面有哪些接口 如何减小代码压缩的体积 貌似只有最开始的一家公司问了好多关于Webpack的，我完全招架不住。 其他 主要讲了一下自动化编译平台里面的一些东西 计算机网络关于计算机网络，大部分都是第二轮 CTO 或者技术主管的面试会遇到。 HTTP的状态码：304、401代表什么 经过一次面试之后，我就把《图解HTTP》简单看了一遍，把一些比较关键的东西记了一下 HTTP缓存有哪些方式，是否了解协商缓存 第二轮面试经常会被问到的问题，也会和其他问题关联在一起，比如性能优化的方案，关于缓存，请求头等等 HTTP请求头有哪些 HTTP2.0 相比于 HTTP1.1 做了哪些优化 也是图解HTTP里面可以找到的，只不过平时工作不会去注意这方面的东西。 项目部署的更新机制，增量更新，缓存入口等等 这些其实都是和平时的工作密不可分的，要充分理解平时的工作内容，就算自己不参与平台的建设，也需要稍微了解一下。 简单总结 面试前的准备很重要，问的东西会比较全面，很多知识可能是盲区，但是也需要去了解一下，不要无话可说。 盲区之所以叫盲区，是因为我们自己意识不到。所以我们可以通过各种各样的面试练习去找到我们的盲区。 基础知识的积累很重要，有些非常底层的东西，如果深入了解，可能会有其他发现。 平时的工作，过程很重要，或许平时我们工作的时候注重的是结果，但是面试的时候，拼的是我们工作的过程。对过程的理解（不是了解），理解平时的一些操作的原因和原理。 心态很重要，我们可能会经历很多挫折，没有人喜欢失败，但是面试总会经历很多失败，有时候甚至会怀疑自己，但这些，都是磨炼，不是折磨，我们要正确面对和认识我们所有的经历，从中获得提高。","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"http缓存：强制缓存和协商缓存","slug":"http-cache","date":"2021-03-10T16:00:00.000Z","updated":"2023-12-06T15:25:19.244Z","comments":true,"path":"2021/03/11/http-cache/","link":"","permalink":"https://github.com/beat-the-buzzer/2021/03/11/http-cache/","excerpt":"","text":"cache-control：缓存控制，可以设置有效期，可以跳过强缓存，可以不缓存。 etag 和 last-modified：设置协商缓存，需要客户端和服务端共同处理。 发请求–&gt;看资源是否过期–&gt;过期–&gt;请求服务器–&gt;服务器对比资源是否真的过期–&gt;没过期–&gt;返回304状态码–&gt;客户端用缓存的老资源。 我们可以在性能优化的问题里提到强制缓存和协商缓存，这个对于前端开发者来说是一个亮点。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://github.com/beat-the-buzzer/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"http","slug":"http","permalink":"https://github.com/beat-the-buzzer/tags/http/"}]},{"title":"前端工程化——Webpack简单总结","slug":"webpack-basic","date":"2021-03-10T16:00:00.000Z","updated":"2023-12-06T15:25:19.248Z","comments":true,"path":"2021/03/11/webpack-basic/","link":"","permalink":"https://github.com/beat-the-buzzer/2021/03/11/webpack-basic/","excerpt":"","text":"什么是webpack，使用webpack有什么好处webpack 是个静态模块打包工具。在 webpack 看来，项目里所有资源皆模块，利用资源依赖关系，把各模块之间关联起来。 简单讲就: webpack 对有依赖关系的多个模块文件进行打包处理后，生成浏览器可以直接高效运行的资源。 通过入口文件开始，利用递归找到直接依赖或间接依赖的所有模块，并在内部构建一个能映射出项目所需的所有模块的依赖图，并进行webpack打包生成一个或多个bundle文件。 webpack输出了哪些？ entry output module plugins 什么是 loader? 什么是 plugin? loader：webpack只能解析JavaScript文件，而loader作用是让webpack拥有了加载和解析非JS文件的能力。使用module.rules对loader进行配置。 plugin：在webpack构建流程中的特定时机注入扩展逻辑，让它具有更多的灵活性。每个plugin都是一个实例，通过构造函数传递参数。 分别介绍 bundle，chunk，module 是什么bundle：是由 webpack 打包出来的文件， chunk：代码块，一个 chunk 由多个模块组合而成，用于代码的合并和分割。 module：是开发中的单个模块，在 webpack 的世界，一切皆模块，一个模块对应一个文件，webpack 会从配置的 entry 中递归开始找出所有依赖的模块。 模块热更新（替换）HMR是什么当你对代码修改并保存后，将会对代码进行重新打包，并将改动的模块发送到浏览器端，浏览器用新的模块替换掉旧的模块，去实现局部更新页面而非整体刷新页面。 webpack 的构建流程是什么? 初始化参数：比如npm start、webpack -w 开始编译：读取webpack的配置 确定入口，entry，找出入口以及他们的依赖文件 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理； 完成模块编译：在使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输入资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表。 输入完成 如何提高webpack的构建速度？ 使用CommonsChunkPlugin来提取公共代码 通过externals配置来提取常用库 利用 DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引用但是绝对不会修改的npm包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。 使用 Happypack 实现多线程加速编译 使用 webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采用了多核并行压缩来提升压缩速度 使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码 webpack与grunt、gulp的不同 grunt和gulp是基于任务和流（Task、Stream）的。类似jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个web的构建流程。 webpack是基于入口的。webpack会自动地递归解析入口所需要加载的所有资源文件，然后用不同的Loader来处理不同的文件，用Plugin来扩展webpack功能。（依赖关系） 如何在项目中实现按需加载 对于 Element-UI 或者 Ant-Design，可以使用 babel-plugin-component 和 babel-plugin-import进行配置。 通过import()语句来控制加载时机，webpack内置了对于import()的解析，最终生成的chunk是一个Promise。所以我们最终需要在我们的环境中新增Promise的polyfill。","categories":[{"name":"工程化","slug":"工程化","permalink":"https://github.com/beat-the-buzzer/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"工程化","slug":"工程化","permalink":"https://github.com/beat-the-buzzer/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"webpack","slug":"webpack","permalink":"https://github.com/beat-the-buzzer/tags/webpack/"}]},{"title":"HTTP状态码总结","slug":"http-code","date":"2021-03-09T16:00:00.000Z","updated":"2023-12-06T15:25:19.245Z","comments":true,"path":"2021/03/10/http-code/","link":"","permalink":"https://github.com/beat-the-buzzer/2021/03/10/http-code/","excerpt":"","text":"什么是状态码HTTP状态码负责表示客户端HTTP请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。 状态码的类别 状态码 类别 原因 1XX 信息性状态码 接收的请求正在处理 2XX 成功状态码 请求正常处理完毕 3XX 重定向状态码 需要进行附加操作以完成请求 4XX 客户端错误状态码 服务器无法处理请求 5XX 服务器错误状态码 服务器处理请求出错 2XX 成功200 OK表示客户端发来的请求在服务器端被正常处理了 204 No Content表示服务器接收的请求以及成功处理，返回的报文里不存在任何实体，因此返回204之后，页面不会进行更新。 一般只需要从客户端往服务器发送信息，客户端不需要发送信息的情况下，使用这个状态码。 应用场景：客户端埋点，收集用户操作习惯。 206 Partial Content该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。 应用场景：下载文件 3XX 重定向301 Moved Permanently永久重定向，表示请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。 302 Not Found临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望 用户(本次)能使用新的 URI 访问。 303 See Other该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 304 Not Modified该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。 常见的应用就是和缓存相关。 4XX 客户端错误400 Bad Request该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。 401 Unauthorized该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、 DIGEST 认证)的认证信息。 需要进行身份认证 403 Forbidden该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要 给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。 比如用户没有权限访问某些资源，服务器就是返回这个错误信息。 404 Not Found该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服 务器端拒绝请求且不想说明理由时使用。 5XX服务器错误500 Internal Server Error该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。 503 Service Unavailable该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法 处理请求。","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://github.com/beat-the-buzzer/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"http","slug":"http","permalink":"https://github.com/beat-the-buzzer/tags/http/"}]},{"title":"HTTP请求类型总结","slug":"http-type","date":"2021-03-09T16:00:00.000Z","updated":"2023-12-06T15:25:19.245Z","comments":true,"path":"2021/03/10/http-type/","link":"","permalink":"https://github.com/beat-the-buzzer/2021/03/10/http-type/","excerpt":"","text":"GET: 获取资源GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器 端解析后返回响应内容。 例如：请求图片资源、html资源 POST: 传输实体主体POST方法用来传输实体的主体。虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用 POST 方法。虽说POST的功能与GET很相似，但POST的主要目的并不是获取响应的主体内容。 GET参数会带到URL上，POST参数会放到请求体里面。 HEAD: 获得报文首部这个类型和GET类似，只不过这个类型是请求头部信息。 PUT: 传输文件DELETE: 删除文件OPTIONS: 询问支持的方法一般是作为一个试探的请求，比如跨域请求发起的时候，会先发一个OPTIONS的请求。 TRACE: 追踪路径CONNECT: 要求用隧道协议连接代理一些问题 GET 和 POST 有什么区别？ 传输方式不同，GET请求是在URL上，POST是通过请求体。 安全性不同，GET直接把参数暴露在URL上，所以安全性较差。 GET是只读的（幂等） PUT 和 POST 有什么区别 也是幂等性的差别 HTTP 请求报文是什么样子的 请求行：包括请求类型 URL 协议版本 请求头：由键值对组成，包括 User-Agent、Accept、Host等等 请求体：请求携带的数据 HTTP 响应的报文是什么样的 响应行：包括协议版本、状态码、状态短语 响应头：响应首部 响应体：服务器返回的数据 首部字段有哪些，有什么作用 通用首部字段 请求首部字段 响应首部字段 实体首部字段 cache-control 控制缓存 connection 连接管理 keep-alive transfer-encoding 报文的编码格式 使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。 6、HTTPS是如何保证安全的？ https是安全版的http，因为http协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全。 对称加密：加密密钥和解密密钥一样，不够安全。 非对称加密：公钥加密，私钥解密，性能不好。 结合这两种方式，使用对称加密，但是对称加密的密钥使用非对称加密进行处理。 我们需要一个可靠的中间人，也就是安全的第三方颁发证书（CA），确保密钥不会被替换。 为了保证证书的安全，我们使用单项散列函数，例如sha512去保证数据的完整性，也就是数字签名。 HTTP2相对于HTTP1.x有什么优势和特点？ 多路复用，把把 HTTP 协议通信的基本单位缩小为一个一个的帧，使得在请求统一域名下的多个文件更加高效。共享一个连接。 首部压缩（Header Compression） 服务端推送","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://github.com/beat-the-buzzer/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"http","slug":"http","permalink":"https://github.com/beat-the-buzzer/tags/http/"}]},{"title":"逐步实现深拷贝和浅拷贝","slug":"deep-copy","date":"2021-03-07T16:00:00.000Z","updated":"2023-12-06T15:25:19.243Z","comments":true,"path":"2021/03/08/deep-copy/","link":"","permalink":"https://github.com/beat-the-buzzer/2021/03/08/deep-copy/","excerpt":"","text":"数据类型和存储方式JavaScript的数据类型分为基本数据类型和引用数据类型。 基本数据类型：number，string，boolean，null，undefined，symbol 引用数据类型：统称为Object类型，细分的话，有：Object，Array，Date，Function等。 基本数据类型保存在栈内存，栈内存中分别存储着变量的标识符以及变量的值。 1let a = 1; 引用数据类型保存在栈内存，变量名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值。 123let obj = &#123; a: 1&#125;; // 假设存的地址是xxx 所以这两种类型，赋值的时候就能体现出不同之处了： 12let b = a; // 重新开辟了一个空间存储b，重新开辟了一个空间存储b的值，也就是1let obj1 = obj; // 重新开辟了一个空间存储obj1,重新开辟了一个空间存储obj1的值，也就是xxx(上面的假设) 所以我们现在得出，obj存的xxx指向的值发生变化的时候，xxx是不变的，此时通过obj2去访问属性，也是会变化的。 浅拷贝和深拷贝浅拷贝：创建一个新的数据，这个数据有着原始数据属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，所以如果其中一个数据改变了这个地址，就会影响到另一个数据。 深拷贝：深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。在堆中重新分配内存，拥有不同的地址，且值是一样的，复制后的对象与原来的对象是完全隔离，互不影响。 深拷贝的实现方式 先 stringify 再 parse 缺点：忽略了undefined、symbol和函数；对象循环引用时，会报错； Object#assign 扩展运算符 缺点：只能实现一层深拷贝 jQuery的 $.extends 方法 缺点：需要引用第三方库 使用递归的方式，遍历对象中的属性 step1: 遍历对象中的属性，先创建一个新的对象。遍历属性的时候，如果这个属性值是一个对象，那么我们需要把这个属性值再次做拷贝操作。如果属性值是基本类型，就直接赋值给前面创建的新对象。 123456789101112131415161718192021222324252627282930313233343536373839function deepClone(obj)&#123; let objClone = Array.isArray(obj) ? []: &#123;&#125;; if(obj &amp;&amp; typeof obj === \"object\")&#123; for(key in obj)&#123; if(obj.hasOwnProperty(key))&#123; //判断obj子元素是否为对象，如果是，递归复制 if(obj[key] &amp;&amp; typeof obj[key] === \"object\")&#123; objClone[key] = deepClone(obj[key]); &#125;else&#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125;``` step2: 我们需要解决循环引用的问题，如果我们对象里其中一个属性指向了上一层的那个对象，那么我们上面的操作就会死循环。对于循环引用的问题，我们需要在进行拷贝之前，先判断这个对象之前是否被拷贝过，如果被拷贝过，就不需要再进行拷贝，直接返回这个对象就行了。```jsfunction clone(target, map = new Map()) &#123; if (target &amp;&amp; typeof target === 'object') &#123; let cloneTarget = Array.isArray(target) ? [] : &#123;&#125;; if (map.get(target)) &#123; // 先去存储的对象里找一下，该对象有没有被拷贝过，如果有 直接返回 return map.get(target); &#125; // 下面的代码标识该对象没有被拷贝过，此时我们要先把该对象存起来，然后再进行进一步的拷贝操作 map.set(target, cloneTarget); for (const key in target) &#123; cloneTarget[key] = clone(target[key], map); &#125; return cloneTarget; &#125; else &#123; return target; &#125;&#125;; Map数据结构，允许字符串以外的类型的数据作为Map的key，并且这个key是唯一的。 12345var myMap = new Map();var keyObj = &#123;&#125;;myMap.set(keyObj, \"和键 keyObj 关联的值\");myMap.get(keyObj); // \"和键 keyObj 关联的值\"myMap.get(&#123;&#125;); // undefined, 因为 keyObj !== &#123;&#125; step3: 对于一些不可继续拷贝的对象，例如函数、Date()等，我们需要判断具体的类型，使用Object#toString方法。 小结一下实现深拷贝的方式，上面说了很多种，有些可能是项目中使用的，有些是比较完整，但是项目中为了图省事没有这么写的。这里注意的是，如果我们是在面试的过程中被问到了这个问题，我们需要回答比较完整的那种方案，可以循循善诱，先把其他几种简单的说一下，然后说出这些方式的缺点，最后为了解决这些缺点，我们使用了XXX方案，这样才是面试官希望听到的答案。 回答要点： step1: 其他几种方式极其缺点 step2: 描述递归：先判断目标的类型是否是可拷贝的值，然后创建一个新的空对象，再进行遍历属性，如果属性值也是一个可拷贝的值，就继续调用这个拷贝函数，如果不是，就直接返回这个值。然后可以解释一下什么叫做可拷贝的值，以及如何判断该值是可拷贝的值。 step3: 解决循环引用的问题，我们需要一个新的空间来存储已经被拷贝过的对象，每次在遍历对象之前，先去这个空间找一下该对象是否曾经被拷贝过。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"}]},{"title":"CSS——display详解","slug":"display","date":"2021-03-07T16:00:00.000Z","updated":"2023-12-06T15:25:19.243Z","comments":true,"path":"2021/03/08/display/","link":"","permalink":"https://github.com/beat-the-buzzer/2021/03/08/display/","excerpt":"","text":"display有很多属性值，我们在这里只介绍几个常用的，重要的，以及他们之间可能存在的一些问题和差异。 block设置了block元素，那么这个元素就遵循盒子模型的规则，宽高、边距都是可以设置的。 块元素独占一行。 inlineinline元素理解为盒子内部的“流”元素，他的形状完全取决于容器，手动设置宽高都是无效的。 inline-block外部看是“流”，内部看是“块”，比如一行内有多个按钮，如果都是inline-block，那么这些按钮可以在一行内进行布局，并且可以设置他们的宽高。 inline-block 容易产生的问题空白间隙 12345678910&lt;style&gt;.inline-block &#123; display: inline-block;&#125;&lt;/style&gt;&lt;div class=\"wrapper\"&gt; &lt;div class=\"inline-block\"&gt;&lt;/div&gt; &lt;div class=\"inline-block\"&gt;&lt;/div&gt; &lt;div class=\"inline-block\"&gt;&lt;/div&gt;&lt;/div&gt; 显然，每个inline-block元素中间，都会有回车/Tab/空格，这些会造成三个inline-block元素之间存在一点间隙。 解决方案1：设置容器的字体大小：font-size: 0 解决方案2：在HTML中不换行，当然这会降低代码的可读性，所以我们还有另外的方法，就是使用HTML中的注释： 12345&lt;div class=\"wrapper\"&gt;&lt;!-- --&gt;&lt;div class=\"inline-block\"&gt;&lt;/div&gt;&lt;!-- --&gt;&lt;div class=\"inline-block\"&gt;&lt;/div&gt;&lt;!-- --&gt;&lt;div class=\"inline-block\"&gt;&lt;/div&gt;&lt;!----&gt;&lt;/div&gt; 解决方案3：使用Webpack或者Gulp这样的工具，对代码进行压缩处理，消除空格、回车、Tab。 使用gulp-htmlmin压缩html","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/beat-the-buzzer/tags/CSS/"}]},{"title":"读书笔记系列——少有人走的路：心智成熟的旅程","slug":"reading-tips-3","date":"2021-01-26T16:00:00.000Z","updated":"2023-12-06T15:25:19.247Z","comments":true,"path":"2021/01/27/reading-tips-3/","link":"","permalink":"https://github.com/beat-the-buzzer/2021/01/27/reading-tips-3/","excerpt":"","text":"点击下载读书笔记的PDF 书名：《少有人走的路——心智成熟的旅程》 作者：M·斯科特·派克 【内容简介】 这本书处处透露出沟通与理解的意味，它跨越时代的限制，帮助我们探索爱的本质，引导我们过上崭新、宁静而丰富的生活；它帮助我们学习爱，也学习独立；它教诲我们成为更称职的、更有理解心的父母。归根到底，它告诉比我们怎样找到真正的自我。 正如开篇所言：人生苦难重重。M·斯科特·派克让我们更加清楚：人生是一场艰辛之旅，心智成熟的旅程相当漫长。但是，他没有让我们感到恐惧，相反，他带领我们去经历一系列艰难乃至痛苦的转变，最终达到自我认知的更高境界。 【主要内容】第一部分：自律 自律是解决人生问题最主要的工具，也是消除人生痛苦最重要的方法。 所谓自律，就是主动要求自己以积极的态度去承受痛苦，解决问题。 推迟满足感 推迟满足感，就是不贪图暂时的安逸，先苦后甜，重新设置人生快乐去痛苦的次序：首先，面对问题并感受痛苦；然后，解决问题并享受更大的快乐。在充满问题和痛苦的人生中，推迟满足感是唯一可行的生活方式。 家庭教育起相当大的作用。 父母遵守自律的原则，需要给孩子做出榜样； 人们容易忽视问题，等待问题自己消失，反映出人们不愿推迟满足感的心理。 承担责任 神经官能症：认为错在自己 人格失调症：把错误归咎于旁人 你不能解决问题，你就会成为问题。 忠于事实 移情：过时的地图 定义：把产生和适用与童年时期的那些感知世界、对世界做出反应的方式，照搬到成年后的环境中，尽管这些方式已经不再适用于新的环境。 逃避现实的痛苦是人类的天性，只有通过自律，再次逐渐克服现实的痛苦。 迎接挑战 心理治疗，不仅仅是为了寻求安慰，更要迎接挑战，解决问题 隐瞒真相 白色谎言：隐瞒部分真相，善意的谎言 黑色谎言：叙述的情况与现实不符，指鹿为马 保持平衡1. 确立富有弹性的约束机制 2. 灵活的情绪反馈系统 3. 需要、目标、责任之间保持平衡，放弃是原则 抑郁的价值 放弃过去的自我 无需对外界要求作出回应的婴儿状态 无所不能的幻觉 完全占有父母的欲望 童年的依赖感 自己心中被扭曲了的父母形象 青春期自以为拥有无穷潜力的感觉 无拘无束的自由 青年时期的灵巧与活力 青春的性吸引力 长生不老的空想 对子女的权威 各种各样暂时性的权利 身体永远健康 自我以及生命本身 放弃与新生 超越现有的一切 清除熟悉的过去 追求新鲜的未来 让事物进入自己的灵魂 获得的永远比放弃的 第二部分：爱 爱的定义 爱是人们自律的原动力 爱，是为了促进自己和他人心智成熟，而不断拓展自我界限，实现自我完善的一种意愿； 爱与非爱最显著的区别之一，就在于当事人意识和潜意识中的目标是否一致。如果不一致，就不是真正的爱； 爱是一个长期、渐进的过程。爱意味着心灵的不断成长和心智的不断成熟； 真正意义上的爱，既是爱自己，也是爱他人； 爱需要付出努力，去跨越原来的界限；不能停留在口头上，要付出行动；不能坐享其成，要真诚付出； 爱是一种意愿——只有强大到足以转化成心动的欲望，才叫意愿。 自我界限 婴儿能够区分出自己和外在世界更多的不同，这样的认知就是自我界限； 有人把自我界限当做保护伞 真正的爱是一种扩展自我的体验，所以它与自我界限密切相关； 依赖不是爱 过分的依赖导致病态的人生； “消极性依赖人格失调症”，不在乎依赖的对象是谁，只在乎别人能为他们做什么，却从不考虑自己能为对方付出多少； 精神贯注不完全是爱 精神贯注：被自我界限之外的对象吸引，促使我们产生冲动，想把激情乃至生命献给对方； 那些与心智成熟无关，不能给心灵带来任何滋养的精神贯注，都不是真正意义上的爱； 培养某种爱好，是自我滋养的有效手段； 溺爱 “自我牺牲” 受虐狂：把自我牺牲当做真正的爱；潜意识里是恨，渴望得到发泄和补偿； 爱从某种意义上是自私的，最终追求的是自我完善； 爱，不是感觉 爱是实际行动，是真正的付出； 真正的爱，需要投入和奉献，需要付出全部的智慧和力量； 关注的艺术 努力倾听 倾听是双向的 失落的风险 独立的风险 自尊自爱 投入的风险 冲突的风险 以爱的名义去指责爱的人 自我反省：诚实和谦虚 爱与自律 爱与独立 爱者与被爱者都不是对方的附属品。 爱与心理治疗 爱的神秘性 第三部分：成长与信仰 人人都有自己的信仰，对人生的认识和了解就属于信仰的范畴。 信仰与世界观 人的信仰都来自于其文化环境 形成信仰的基本因素来自我们成长的家庭环境 要建立与现实相适应的信仰与世界观，我们必须不断学习，增进对世界的认识。 科学与信仰 增加认知，扩大视野 逐步以科学的信仰来代替父母的信仰，向小宇宙法则提出挑战 真实、观察、知识、怀疑、经验 案例一 案例二 案例三 案例四 第四部分：恩典 我们之所以能具备爱的能力和成长的意愿，不仅取决于童年时父母爱的滋养，也取决于我们一生中对恩典的接纳。 健康的奇迹 生理上的疾病，未必一定和心理疾病有关，但事实上，二者之间的联系却是普遍存在的。我们往往知道是什么原因导致我们生病，却很少了解是什么原因让我们保持健康。 潜意识的奇迹 有时候，人们会无意识地暴露出自己内心深处的东西，这对心理治疗会有一定的帮助 梦的解析 好运的奇迹 恩典的定义 它们具有滋养生命、促进心智成熟的作用 它们的具体左右机制要么仍旧未被人们完全了解，要么完全不为人知 它们是人类世界中的普遍现象 尽管它们可能或多或少受到意识的影响，但它们的根源位于意识和主观思维之外 进化的奇迹 https://www.zhihu.com/question/24053383 能量自然地从高处流向低处，使熵不断增加，熵增原理 进化实际上是从底层进化到顶层，违反了熵增原理 心灵的进化也是从原始的心灵进化成为成熟的心灵 这里其实书中的描述不是那么准确，生物之所以会进化，是因为如果不进化，就会无法生存甚至灭绝。 生物的进化，其实是要拼命活下去，心灵的进化，同样也需要不断努力； 开始与结束 熵与原罪 阻碍心智成熟的障碍，最大的障碍就是懒惰； 邪恶的问题 意识的进化 观察和认知 力量的本质 政治的力量和心灵的力量 愉快和谦逊 力量越多，越累，将军和士兵 孤独感 俄瑞斯忒斯的传说 对恩典的抗拒 心理治疗的本质，就是自律的工具 迎接恩典降临 【精彩摘抄】 人生是一个不断面对问题并解决问题的过程。问题可以开启我们的智慧，激发我们的勇气。为解决问题而努力，我们的思想和心灵就会不断成长，心智就会不断成熟。 他们都面临一个共同的问题——感觉自己不能够“应付”或者改变现状，因此产生恐惧、无助感和自我怀疑。 生命的本质就是不断改变、成长和衰退的过程。选择了生活与成长，也就选择了面对死亡的可能性。 冲突或者批评，是人际关系中特殊的控制权力，如果恰当地运用，就可以改进人际关系的进程，甚至改变所爱的人的一生。如果它遭到滥用，就会产生消极的结果。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"前端面试之手写代码系列（基础篇）","slug":"writing-code01","date":"2020-12-27T16:00:00.000Z","updated":"2023-12-06T15:25:19.249Z","comments":true,"path":"2020/12/28/writing-code01/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/12/28/writing-code01/","excerpt":"","text":"下面的几个是JS里面比较基础和常用的东西，通过用代码实现，可以让我们更深刻地了解这些方法的底层原理，以及解决了哪些问题。大部分的方法实现在《你不知道的JavaScript》里面都有。 疫情的存在，使得我们几乎都是线上面试，几乎无法现场手写代码。但是，手写代码是面试中很重要的一环，因为这个比较综合、全面、深刻。 new 先创建一个新的、空的实例对象 将实例对象的原型指向构造函数的原型 将构造函数内部的this，修改为指向实例 返回实例对象：判断构造函数的返回值是否为对象，如果是对象，就使用构造函数的返回值，否则返回创建的对象 1234567891011121314151617181920212223242526272829303132 function New(func) &#123; // 声明一个中间对象，该对象为最终返回的实例 var res = &#123;&#125;; if (func.prototype !== null) &#123; // 将实例的原型指向构造函数的原型 res.__proto__ = func.prototype; &#125; // ret为构造函数的执行结果 // 将构造函数内部的this指向修改为指向res // 通过apply实现 var ret = func.apply(res, [].slice.call(arguments, 1)); // 当我们在构造函数中指定了返回的对象时，new执行的结果就是这个对象 if ((typeof ret === 'object' || typeof ret === 'function') &amp;&amp; ret !== null) &#123; return ret; &#125; // 默认返回res return res;&#125;var Person = function (name) &#123; this.name = name;&#125;Person.prototype.getName = function () &#123; return this.name;&#125;var p1 = New(Person, 'Tom');var p2 = New(Person, 'Jerry');p1.getName(); // Tomp2.getName(); // Jerry call123456789101112// 思路：将要改变this指向的方法挂到目标this上执行并返回Function.prototype.mycall = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('not funciton') &#125; context = context || window context.fn = this let arg = [...arguments].slice(1) let result = context.fn(...arg) delete context.fn return result&#125; apply12345678910111213141516// 思路：将要改变this指向的方法挂到目标this上执行并返回Function.prototype.myapply = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('not funciton') &#125; context = context || window context.fn = this let result if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; delete context.fn return result&#125; bind12345678910111213141516// 思路：类似call，但返回的是函数Function.prototype.mybind = function (context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('Error') &#125; let _this = this let arg = [...arguments].slice(1) return function F() &#123; // 处理函数使用new的情况 if (this instanceof F) &#123; return new _this(...arg, ...arguments) &#125; else &#123; return _this.apply(context, arg.concat(...arguments)) &#125; &#125;&#125; instanceof这个原理就是查找原型链，看看实例的原型是否在我们希望判断的对象的原型链上。调用的内置的函数[[HasInstance]] 12345678910// 参数都是两个对象function instanceOf(leftObj, rightObj) &#123; let proto = leftObj.__proto__; let prototype = rightObj.prototype while(true) &#123; if(proto === null) return false if(proto === prototype) return true proto = proto.__proto__; &#125;&#125; 排序关于排序，在之前一篇文章里已经写了：算法系列——排序算法 如果是求稳，可以使用选择排序或者冒泡排序这样逻辑简单的； 如果想更进一步，可以使用递归方式的归并排序； 还想更进一步，就可以使用稍微有点复杂的快速排序； 当然，这些排序算法的原理还是需要去弄清楚的。 去重去重的方法，之前也有总结过：数组去重的N个方法 其实面试主要考察的是思路，如果你的试卷上用Set一行解决，其实是很难得到高分的； 求稳的大思路，应该是定义新的数组，然后遍历原数组，如果在新的数组里没有遍历的值的时候，就把数据放到新数组里面； 更进一步的思路，是利用对象的Key、Map 的唯一性； 新奇的思路，寻找元素首次出现的位置是否和当前位置的元素相等； 面试的过程中，我们不仅仅是要提供问题的解决思路，也可以说一下我们这个思路的局限性。面试和工作的思路不一样，面试是为了展示能力，工作是为了解决问题。","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"前端面试之手写代码系列（应用篇）","slug":"writing-code02","date":"2020-12-27T16:00:00.000Z","updated":"2023-12-06T15:25:19.249Z","comments":true,"path":"2020/12/28/writing-code02/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/12/28/writing-code02/","excerpt":"","text":"防抖与节流关于防抖与节流，在之前一篇文章里已经写了：防抖节流操作总结 文章里还做了科里化的操作，就是下面即将要写的，目的是把防抖和节流做成一个公共的方法。 科里化与函数式编程关于科里化与函数式编程，在之前一篇文章里已经写了：函数式编程 文章里有大量的举例和应用场景。 深拷贝简单版本1：先stringfy再parse，无法处理值为日期、函数等类型的数据； 简单版本2：ES6扩展运算符，只能处理一层数据，对于深层次的对象无法处理； 简单版本3：ES6 Object.assign({}, ...) 简单版本4：Jquery $.extends()方法 算法版本：主要是用了递归的思想 123456789101112const deepClone = (target, cache = new WeakMap()) =&gt; &#123; if(target === null || typeof target !== 'object') &#123; return target &#125; if(cache.get(target)) &#123; return target &#125; const copy = Array.isArray(target) ? [] : &#123;&#125; cache.set(target, copy) Object.keys(target).forEach(key =&gt; copy[key] = deepClone(obj[key], cache)) return copy&#125; Rem基本设置关于Rem基本设置，在之前一篇文章里已经写了：移动端适配之淘宝方案分析 1234567891011121314function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; if (width / dpr &gt; 540) &#123; width = 540 * dpr; &#125; var rem = width / 10; // 意味着100%的宽度就是10rem docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem;&#125;window.addEventListener('resize', function () &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300);&#125;, false); Promise","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"前端面试之手写代码系列（进阶篇）","slug":"writing-code03","date":"2020-12-27T16:00:00.000Z","updated":"2023-12-06T15:25:19.249Z","comments":true,"path":"2020/12/28/writing-code03/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/12/28/writing-code03/","excerpt":"","text":"EventBus123456789101112131415161718192021222324252627// 组件通信，一个触发与监听的过程class EventEmitter &#123; constructor () &#123; // 存储事件 this.events = this.events || new Map() &#125; // 监听事件 addListener (type, fn) &#123; if (!this.events.get(type)) &#123; this.events.set(type, fn) &#125; &#125; // 触发事件 emit (type) &#123; let handle = this.events.get(type) handle.apply(this, [...arguments].slice(1)) &#125;&#125;// 测试let emitter = new EventEmitter()// 监听事件emitter.addListener('ages', age =&gt; &#123; console.log(age)&#125;)// 触发事件emitter.emit('ages', 18) // 18 双向绑定核心点就是当数据变化的时候，触发DOM的更新，DOM通过用户操作更新的时候，改变数据。 1234567891011121314151617181920let obj = &#123;&#125;let input = document.getElementById('input')let span = document.getElementById('span')// 数据劫持Object.defineProperty(obj, 'text', &#123; configurable: true, enumerable: true, get() &#123; console.log('获取数据了') &#125;, set(newVal) &#123; console.log('数据更新了') input.value = newVal span.innerHTML = newVal &#125;&#125;)// 输入监听input.addEventListener('keyup', function(e) &#123; obj.text = e.target.value&#125;)","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试题系列——vue相关（进阶篇）","slug":"interview-for-vue03","date":"2020-12-22T16:00:00.000Z","updated":"2023-12-06T15:25:19.245Z","comments":true,"path":"2020/12/23/interview-for-vue03/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/12/23/interview-for-vue03/","excerpt":"","text":"Vue、React相关的东西，我们如果仅仅停留在使用的层面，那么我们将无法通过任何一场面试。下面的一些关于Vue的问题，是我在阅读源码的过程中整理出来的，可能会遇到的问题。","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试题系列——vue相关（应用篇）","slug":"interview-for-vue02","date":"2020-12-22T16:00:00.000Z","updated":"2023-12-06T15:25:19.245Z","comments":true,"path":"2020/12/23/interview-for-vue02/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/12/23/interview-for-vue02/","excerpt":"","text":"Vue、React相关的东西，我们如果仅仅停留在使用的层面，那么我们将无法通过任何一场面试。下面的一些关于Vue的问题，是我总结的一些使用技巧，以问题的方式总结出来。 Vue 如何在组件间传值 父组件传给子组件，props， 子组件传给父组件，父组件绑定了一个事件之后，子组件使用 $emit 另外，父组件可以拿到子组件对象，然后去调用子组件的方法或者获取子组件里面定义的值； 兄弟组件，可以先找他们的一个公共的父组件，然后把问题转化成父子组件之间的传值； EventBus，搭建一个桥梁，使得组件间的信息都可以互通； Vuex，是一种状态管理工具，我们可以共享组件的状态，功能类似于 React 中的 Redux 或者 Mobx； Vue 的生命周期created =&gt; before mounted =&gt; before updated =&gt; before destroyed =&gt; before","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"探索addEventListener","slug":"addEventListener","date":"2020-12-14T16:00:00.000Z","updated":"2023-12-06T15:25:19.242Z","comments":true,"path":"2020/12/15/addEventListener/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/12/15/addEventListener/","excerpt":"","text":"最近使用了 default-passive-events 解决滑动卡顿的问题，看源码的时候，发现这个node包是修改 addEventListener 的第三个参数的默认值，所以有必要先总结一下 addEventListener 的相关知识。 addEventListener的定义EventTarget.addEventListener() 方法将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 先看一段EventTarget 在TypeScript中的接口定义： 12345678910111213141516171819202122interface EventTarget &#123; /** * Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched. * The options argument sets listener-specific options. For compatibility this can be a * boolean, in which case the method behaves exactly as if the value was specified as options's capture. * When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET. * When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in §2.8 Observing event listeners. * When set to true, options's once indicates that the callback will only be invoked once after which the event listener will * be removed. * The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture. */ addEventListener(type: string, listener: EventListenerOrEventListenerObject | null, options?: boolean | AddEventListenerOptions): void; /** * Dispatches a synthetic event event to target and returns true * if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise. */ dispatchEvent(event: Event): boolean; /** * Removes the event listener in target's event listener list with the same type, callback, and options. */ removeEventListener(type: string, callback: EventListenerOrEventListenerObject | null, options?: EventListenerOptions | boolean): void;&#125; addEventListener可以接收三个参数：事件类型字符串、事件绑定的回调以及其他配置项。我们在这里主要是研究一下第三个参数。 第三个参数可以是bool类型123……boolean, in which case the method behaves exactly as if the value was specified as options&#39;s capture.…… 根据文档，我们知道，这里的 boolean 的值，就是和下面的capture是一样的。为什么支持 boolean 类型，主要是为了兼容早期的浏览器实现方式。 第三个参数可以是对象1234567interface EventListenerOptions &#123; capture?: boolean;&#125;interface AddEventListenerOptions extends EventListenerOptions &#123; once?: boolean; passive?: boolean;&#125; 我们可以从接口的定义里了解到，addEventListener的第三个参数是对象的时候，可以有三个属性： capture: 默认值为false（即 使用事件冒泡），是否使用事件捕获； once: 默认值为false. 是否只调用一次，if true，会在调用后自动销毁listener。 passive: 默认值为false。如果是true, 意味着listener永远不远调用preventDefault方法，如果又确实调用了的话，浏览器只会console一个warning，而不会真的去执行preventDefault方法。 通常为了滑动的性能，我们都需要把 滑动元素的touchmove事件的passive设置成true，保证了在页面滚动时不会因为自定义事件中调用了 preventDefault 而阻塞页面渲染。 相关应用1. npm: https://www.npmjs.com/package/default-passive-events 2. GitHub: https://github.com/zzarcon/default-passive-events default-passive-events 源码解读其实这个代码只做了一件事，就是给 addEventListener 的第三个参数设定一个默认值。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; eventListenerOptionsSupported &#125; from './utils';const defaultOptions = &#123; passive: true, capture: false&#125;;const supportedPassiveTypes = [ 'scroll', 'wheel', 'touchstart', 'touchmove', 'touchenter', 'touchend', 'touchleave', 'mouseout', 'mouseleave', 'mouseup', 'mousedown', 'mousemove', 'mouseenter', 'mousewheel', 'mouseover'];const getDefaultPassiveOption = (passive, eventName) =&gt; &#123; if (passive !== undefined) return passive; return supportedPassiveTypes.indexOf(eventName) === -1 ? false : defaultOptions.passive;&#125;;const getWritableOptions = (options) =&gt; &#123; const passiveDescriptor = Object.getOwnPropertyDescriptor(options, 'passive'); return passiveDescriptor &amp;&amp; passiveDescriptor.writable !== true &amp;&amp; passiveDescriptor.set === undefined ? Object.assign(&#123;&#125;, options) : options;&#125;;const overwriteAddEvent = (superMethod) =&gt; &#123; EventTarget.prototype.addEventListener = function (type, listener, options) &#123; const usesListenerOptions = typeof options === 'object' &amp;&amp; options !== null; const useCapture = usesListenerOptions ? options.capture : options; options = usesListenerOptions ? getWritableOptions(options) : &#123;&#125;; options.passive = getDefaultPassiveOption(options.passive, type); options.capture = useCapture === undefined ? defaultOptions.capture : useCapture; superMethod.call(this, type, listener, options); &#125;; EventTarget.prototype.addEventListener._original = superMethod;&#125;;const supportsPassive = eventListenerOptionsSupported();if (supportsPassive) &#123; const addEvent = EventTarget.prototype.addEventListener; overwriteAddEvent(addEvent);&#125; 1234567891011121314151617// 判断浏览器是否支持 passive， 在get()里面去拦截属性的访问export const eventListenerOptionsSupported = () =&gt; &#123; let supported = false; try &#123; const opts = Object.defineProperty(&#123;&#125;, 'passive', &#123; get() &#123; supported = true; &#125; &#125;); window.addEventListener('test', null, opts); window.removeEventListener('test', null, opts); &#125; catch (e) &#123;&#125; return supported;&#125; 1. 兼容处理我们需要先判断浏览器是否支持 passive，这里就提供了一个不错的思路，使用 Object.defineProperty 的 get() 去进行拦截，我们比较熟悉的 Vue 的实现思路其实和这个类似。 2. 函数式编程这应该是我第三次提到函数式编程了，前两次分别是函数式编程和防抖防抖节流操作总结。反复提到这个思想，是因为在使用的时候，我们可以把新增的逻辑写在高阶函数里面，这样就不用去处理原方法了，并且方便移植代码。 3. 最终使用这个库的效果如果 passive 和 capture没有设置的时候，一律默认 passive: true, capture: false 12345678document.addEventListener('mouseup', onMouseUp); // &#123;passive: true, capture: false&#125;document.addEventListener('mouseup', onMouseUp, true); // &#123;passive: true, capture: true&#125;document.addEventListener('mouseup', onMouseUp, false); // &#123;passive: true, capture: false&#125;document.addEventListener('mouseup', onMouseUp, &#123;passive: false&#125;); // &#123;passive: false, capture: false&#125;document.addEventListener('mouseup', onMouseUp, &#123;passive: false, capture: false&#125;); // &#123;passive: false, capture: false&#125;document.addEventListener('mouseup', onMouseUp, &#123;passive: false, capture: true&#125;); // &#123;passive: false, capture: true&#125;document.addEventListener('mouseup', onMouseUp, &#123;passive: true, capture: false&#125;); // &#123;passive: true, capture: false&#125;document.addEventListener('mouseup', onMouseUp, &#123;passive: true, capture: true&#125;); // &#123;passive: true, capture: true&#125; 小结：看似只总结了 addEventListener，实际上关联了很多其他的知识。前端技术总会互相联系的，当你发现了这个联系，你就会获得探索的乐趣。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://github.com/beat-the-buzzer/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"读书笔记系列——吃掉那只青蛙","slug":"reading-tips-2","date":"2020-12-08T16:00:00.000Z","updated":"2023-12-06T15:25:19.247Z","comments":true,"path":"2020/12/09/reading-tips-2/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/12/09/reading-tips-2/","excerpt":"","text":"点击下载读书笔记的PDF 书名：《吃掉那只青蛙》 作者：[美] 博恩·崔西 【内容简介】 面对艰巨、重要的任务， 不要拖延，立即采取行动，吃掉那只青蛙。 每天吃掉三只青蛙，让你进入前10%的精英行列。 《吃掉那只青蛙》中提出21条时间管理法则，让千万人受益。在过去的20多年里，本书的方法帮助人们成功地实现效率的提升和自我管理，大多数人运用书中的一系列方法和技巧，实现了职位提升，收入翻倍，个人长期目标和人生目标完美实现。 当下，人们面对的各种选择越来越多，不免感到茫然和难以决策，但一个人做出选择的能力将决定你人生的高度。本书通过一系列方法和工具，让你养成优先处理重要任务的习惯，并获得持续性的回报。 马上行动，把未来变成现在，一口一口地吃青蛙，确保自己每天先完成重要的工作，吃掉丑陋的青蛙，你将发挥更卓越的能力，所向披靡，拥有幸福的生活和成功的人生。 【主要内容】 引言：决策能力成为决定人生成就的重要因素 做出正确的选择 吃青蛙的真相（先对最艰巨的任务采取行动） 如果你必须吃掉两只青蛙，那么要先吃那只长得更丑陋的。如果你要完全吃掉一只活青蛙，却只是一直坐在那里盯着它看，看得再久也无济于事 迅速采取行动 迈向成功的习惯（优先处理重要任务） 打造正能量的加速器 成功无捷径（熟能生巧） 养成3D好习惯（decision、discipline、determination） 你能看到什么样的人，你就会成为什么样的人（心理暗示） 明确目标 把目标写在纸上 明确自己想要什么 把你的目标写下来 为目标设置一个完成的最后期限 最糟糕的利用时间的情形之一，是把根本不需要做的事情做得很完美 把所有需要完成的事项都列出来 整理清单，使之成为计划 根据计划采取行动 每天解决一部分问题，向主要目标推进 制定计划 提高回报率 每天节省出两小时 目标不同，计划不同 为项目制定一份计划 将二八法则用于你所有的任务 任务的数量VS任务的重要性 关注重要任务 抵制诱惑，不被小事所引诱。 自我激励 考虑效果 用长期时间观念的思维优化你做出的短期决定。 对时间的配置做出更好的安排 未来的意义常常会左右目前的行动 用长期的时间观念进行思考 遵守强迫效率法则 时间有限，任何人都无法做完所有的事情 最后期限只是借口 有关生产力最大化的三个问题 我的最高价值的工作是什么 我只有把哪件事情做好了才会产生非凡的影响 在此时此刻，对我来说最有价值的事情是什么 学会说“不” 优先级高低之分 当你不再去做那些低优先级的工作时，你的时间和生活才能完全掌握在自己手中。 创造性拖延 把花费时间长的活动设定为次优先级 持续不断地练习使用ABCDE法 一边思考，一边把你思考的结果写在纸上 “应该做”还是“必须做” A类：最重要，且必须完成的事情 B类：应该做的事情，不做的话，后果并不严重 C类：做了大家都愉快，不做也没有人为此感到不悦 D类：可以授权给他人做的事情 完全可以不做的事情 聚焦关键结果领域（key result area） 管理和销售工作中的7大要素 计划、组织、配备人员、授权、监督、检查、报告 明晰关键结果领域至关重要 明确自己的定位 薄弱环节导致工作拖延 一个重要的问题 有什么技能是如果我掌握了并做到极致，就能够给我的事业带来最积极的影响？ 你最弱的关键结果领域会影响你发挥其他技能的水平。 遵守“3个”定律 每天只做一项工作 马上行动起来 改变你的生活 快速列出清单 时间管理是实现目标的方法 工作时间要全身心地工作 平衡是不可选择的 在公司里，时间的质量最关键；在家里，时间的长短最重要。 做好充分的准备再行动 创造舒适的工作空间 为梦想奋斗 迈出第一步 每次到达下一个油桶 穿越撒哈拉沙漠 每次完成一步 升级核心技能 学无止境 在任何领域想要获得成功的最低要求是，要不间断地学习。 成为大师的三个步骤 每天至少阅读一小时 参加有助于你提高工作技能的每一堂课程和讲座 把空闲的时间利用起来 找到最关键的限制因素 找出限制因素 运用80/20法则解决限制因素 从自身找原因 找准原因，对症下药 自我设定压力目标 成为业内的领军者 自己设定最后期限 激励自己将理想转化成行动 控制你跟心灵的对话 建立积极的态度 乐观主义者在任何情况下都会去看事情好的一面 乐观主义者总是能从挫折和苦难中总结经验，吸取教训 乐观主义者总是极力找出问题的解决方法 性格积极、乐观的人会不断地思考和谈论他们的目标。 技术是一个可怕的掌控者 有所选择 不能上瘾 找回属于自己的时间 不要成为高科技的奴隶 如果出现值得关注的大事，有人会告诉你 技术是一名出色的仆人 掌控你的通信 遇到突发事件 掌控你的时间 利用技术掌控你的情绪 高度的专注力 上瘾 多任务引发的幻觉 被验证的结论 把生产力提升到两倍 奶酪和香肠工作法 设定强制关闭机制 任务分解的“奶酪工作法” 创造整块的时间 为整块时间制定时间表 使用时间计划表 把每分钟都利用起来 保持紧迫感 进入最佳状态 引爆自身的高效能 激发动能 马上行动 单独处理每一项任务 一旦开始，全力以赴 不浪费时间 自律 【精彩摘抄】 你不能教会一个人所有的事情，你只能引导他从自身出发，去解决问题。 集中精力去完成最重要的事情，彻底地完成它们，并把它们做好，这是人一生取得巨大的成功、成就，赢得受人尊重的社会地位，获取幸福感的关键所在。 个人高效能工作的最重要的法则之一是10/90法则，即整个工作的前10%的时间用于制定计划、组织工作，那么在实际完成工作的过程中将节约90%的时间。 经常思考你做出的选择、决定和行为是否能产生积极的发展前景及对未来的影响，这是确定你的工作和个人生活中的优先级顺序的最好方法之一。 高科技可以成为你最好的朋友，也可能成为你最大的敌人。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"读书笔记系列——早起魔法","slug":"reading-tips-1","date":"2020-11-26T16:00:00.000Z","updated":"2023-12-06T15:25:19.247Z","comments":true,"path":"2020/11/27/reading-tips-1/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/11/27/reading-tips-1/","excerpt":"","text":"点击下载读书笔记的PDF 书名：《早起魔法》 作者：[美] 杰夫·桑德斯 【内容简介】 书中所提到的”凌晨5点奇迹”，特指为了实现人生宏伟目标而早起、在早餐前掌控好一天的积极行动。 早起只是本书的”表面意义”，养成良好的行为习惯也只是帮助你实现人生目标的有效工具，不懈追求个人成长的最高境界，是成为最好的自己！ 多数人每天都从无序和混乱中开始，或是漫不经心、没精打采地起床，无所事事地打发时间。他们没有收获，几乎整天都是在应付差事。 无法掌控自己生活的人不会快乐，因为他们总要花时间应付混乱生活所带来的难题。掌控自己生活的人是幸福的，他们的时间都用来享受平静生活所带来的好处。 清晨时分，万物宁静而安详，鲜有人来打扰，对有些人来说，这是一天当中唯一属于自己的时间。白天的时间被拉长了，感觉比别人多了2个小时，不是时间在追赶你，而是你在指挥时间。 意识到生命和时间都紧握在自己手中，这使你拥有不可思议的自主权，也为你提供了更多良机，早起只不过是为你打开了机会的大门。 将健康高效的习惯和人生的宏伟目标一致起来，并坚持不懈地执行，你终将收获令自己备感骄傲自豪的人生！ 【主要内容】 凌晨5点奇迹 奇迹：名词。出乎意料且受欢迎的事情，无法从自然或科学角度进行合理的解释，通常被认作是神的旨意；极难达成或者不同寻常的事情、进展或成就。 为什么？ 万物宁静安详，有些人唯一属于自己的时间 掌控，不可思议的自主权 时间管理、计划任务 有哪些成效？ 旺盛的精力 睡眠质量 强身健体 保持高效 保持专注 心情舒畅 升级体质、力量、意志 在首要目标上取得进展 思维清晰 检测健康状态 正确理解凌晨5点 目的是培养自己有计划地掌控自己的时间，不是必须要每天凌晨5点起床 4条承诺 每天制定一个经过深思熟虑的书面计划 以健康的生活习惯来保持最佳的热情和活力 确立短期目标来帮助实现最宏伟的人生目标 追踪进展，对自己的行为负责 读者如何做 计划 执行 反思 追求卓越——主动且有效地行事 安逸是成功的死敌 不要吃垃圾食品，吃水果蔬菜沙拉 不要喝酒买醉，喝水一样解渴 不要借外债，自己攒钱，以备不时之需 不要熬夜，早点睡觉 不要贪恋电视，读一本书 不要逃避与人交流，参与其中享受乐趣 早起的十大好处 有时间做好计划并且有效地执行 完美的独处时间 持续高质量的睡眠状态 旺盛的精力和乐观的心态 强大的专注力 具有创造性的清晰思维 健康的体魄 保持高效能 达成宏伟目标 加入成功人士的行列 满怀激情地起床——如何练就晨型人 喝点迷魂汤：找一个“晨型人”作为学习的榜样 认真计划：做好准备，不训练就跑马拉松，可能会完赛，但是有很大伤害，临时起意的决定，可能会后患无穷，尤其是作为开发人员来说，临时的需求和改动太频繁，终将毁了整个项目。 少喝咖啡，这里可以做出其他推断，比如少抽烟，虽然我不喝咖啡，也不抽烟。没有必要用化学品作为提神的东西，如果真的需要外力，说明该睡觉了。 重新安排晚间活动：不要让电视和社交网络占据太多的时间。 按时睡觉：其实早起的魔法，魔力的最大来源就是早睡，这一点的重要性无需多说。 逐步改变作息时间：其实晚睡也是从学校里面养成的习惯，学校11点半熄灯断电，所以我大学的几年都是11点半之后睡觉，工作之后，一时间没有调整，所以日积月累。现在如果想矫正，只能慢慢来，先尝试提前15分钟。 培养健康习惯：有些有意义的健康习惯可以有意识地去做，比如饭后走动30分钟，周期性爬山等等 万丈高楼平地起——计划一场华丽的冒险 思考个人成长的领域 成为最好的自己 超级高效能7步法 宏伟目标 季度体系 固有习惯 理想惯例 高效能策略 追踪进展 成为达人 确定人生的宏伟目标 那个最棒的自己看起来是什么样子的？ 你在做什么？ 你和谁在一起？ 你对什么事情充满热情并且愿意付出努力？ 当一切进展顺利的时候你在做什么？ 创建宏伟目标清单 你一直想做却从来没时间做的事情是什么？ 完成后会让你感到无比自豪的事情是什么？ 你想效仿成功人士的哪些成就？ 你的个人优化方案（POP：Personal Optimization Plan）是什么样的？ 是什么令你想起来就害怕或者兴奋？ 你曾经尝试过的但最终却未能完成的事情是什么？ 如果不必为时间、金钱或者精力担忧，你会尝试做什么？ 如果你有一个听话的精灵，它能实现你一个愿望，你会许什么愿？ 什么事情能带给你无与伦比的喜悦，而且一旦有了新进展，这份喜悦感还会随之增加？ 你想到的而且应该列在清单上的事情是什么？ 丢掉年度目标——如何达成宏伟目标 工作和任务的增加是为了用掉完成工作所必需的时间。 为什么长期计划不起作用? 人的本性使然。我们天生懒惰，喜欢走捷径，深信有“充足的时间” 缺乏紧迫感 对一年的要做的事情毫无头绪 想得太多长远，脑海中的未来过于理想化 季度体系是什么？ 把一个季度当做一年，拿出以往在年底拼命的态度认真对待当前的季度； 商务领域通常使用季度为单位，3个月有足够的时间认真处理那些极具考验的项目； 如何建立季度体系？ 选择季度周期 清空日程表 筛选重要目标 创建待办事项 建立笔记 安排待办事项 定期反思 强大的终身习惯——改变身心的日常习惯 固有习惯 怀揣计划起床 运动 投身工作 补充习惯 精神抖擞地早起 及时补充水分 必要的独处 注重早餐营养 专注个人成长 运动训练 提前做好计划 理想惯例——如何计划、执行、并重复你最好的一天 习惯、仪式、惯例 建立理想一周安排 获取模板 选择类型 先放大石块 再倒小石子 每周反思 设计晨间惯例 无暇版——没有多余时间的日子，只做最低限度的事情 标准版——给每天最重要的习惯留出足够的时间 安逸版——一般时间较长，用于实施自己喜欢的习惯 自定义——应对突发状况导致的计划被打乱的情况 具体如何去做 准备好笔记本、日程表、或者任务管理器 创建理想的晚间惯例 将晨间惯例和宏伟目标一致起来 专注于提升精力 效仿成功人士 全部写下来 完成清单 高效能——促进质变的高效能策略 困难中蕴藏着机遇 合并 合并任务、项目和活动 合并文档、文件和文件夹 合并文章、笔记和心得 专注 安排专注的时间段 远离干扰 一次只做一件事 零平衡 清零收件箱 清零项目 清零桌面 清零办公区 追踪进展——如何监控、衡量、管理你的生活 每日反思 列出一天的核心习惯，以及完成度、目标、差值 一周反思 收获和成果、失败与改进 问责制度：分享每周的目标和成果 月度反思 坚持执行的日常习惯 需要改进的日常习惯 下个月要如何做才能持之以恒 收获与成果 季度反思 三项收获和成果 三个失败 三个灵光一闪的时刻 年度反思 坚持下来的习惯是什么 达成了哪些重要的里程碑 季度体系的效果如何 凌晨5点达人——进阶策略 安排思考时间 听音乐 立式办公桌 新式愿景板 倒立（有点艰难，改成运动前的拉伸运动） 行动方案——30天行动方案 准备工作 结识其他晨型人 开始早起 创造个人优化方案 蓝图第1步：列出宏伟目标 蓝图第2步：建立季度体系 蓝图第3步：明确固定习惯和补充习惯 蓝图第4步：创建理想周模板 设计理想晨间惯例 理想晚间惯例 蓝图第5步：任务管理器 无纸化：整理自己的文档系统 印象笔记 专注 清零收件箱 清零项目 清零桌面 清零办公区 蓝图第6步：日常习惯追踪表 一周反思 问责合作伙伴 月度反思 季度反思 年度反思 蓝图第7步：安排时间思考 聆听音乐 立式办公桌 新式愿景板 倒立 加入智囊团 大胆行动——每天创造奇迹 四条承诺回顾 每天制定一个经过深思熟虑的书面计划 以健康的生活习惯来保持最佳的热情和活力 确立短期目标来帮助实现最宏伟的人生目标 追踪进展，对自己的行为负责 【精彩摘抄】 卓越并非一个有限目标或者终点，它是一个过程，一场正在进行中的较量，是每天都要面对的战斗。 我认为，不懈追求个人成长的最高境界是成为最好的自己。没有别的事情对我来说更有意义。如果我能够做得更好，那干嘛还要浪费自己的潜能呢？ 不要仅仅因为你觉得自己无法开始而停止梦想。 当然，很可能我们的生活本来就无需去做更多的事。我们要做的是干脆果断地进行取舍，坚定不移地持之以恒，一心一意专心致志，从而在宏伟目标上取得切实的进展。 将成功归功于自己很容易，但是一旦你失败，结果变恰恰相反。当你出了错，耽误了最后期限，或者没有完成任何任务时，是不会轻易坦诚问题出现在自己身上的。 努力工作无疑是件苦差事。但是为最重要的事情努力并不会感到苦。相反，你会觉得这是让人充满意义和成就感的完美方式。","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"读书笔记目录","slug":"reading-tips-contents","date":"2020-11-26T16:00:00.000Z","updated":"2023-12-06T15:25:19.248Z","comments":true,"path":"2020/11/27/reading-tips-contents/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/11/27/reading-tips-contents/","excerpt":"","text":"图片和资源全部保存在码云Gitee上 1. 早起的奇迹 2. 吃掉那只青蛙","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]},{"title":"面试题系列——vue相关（基础篇）","slug":"interview-for-vue01","date":"2020-11-15T16:00:00.000Z","updated":"2023-12-06T15:25:19.245Z","comments":true,"path":"2020/11/16/interview-for-vue01/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/11/16/interview-for-vue01/","excerpt":"","text":"Vue、React相关的东西，我们如果仅仅停留在使用的层面，那么我们将无法通过任何一场面试。下面的一些关于Vue的问题，是我在阅读源码的过程中整理出来的，可能会遇到的问题。 Vue2.x 使用了哪种类型检查工具，有什么好处Flow 在运行之前就可以检测出一些由于类型错误可能会出现的问题，类似的还有 TypeScript。 Vue的构建工具是什么，你还了解哪些其他的构建工具rollup 适用于打包成一个JS库。 Rollup官方：Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序 webpack官方：webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 Gulp官方：基于流的自动化构建工具 Vue的核心思想是什么数据驱动：数据和视图建立一种映射关系，如果期望页面改变，只需要改变数据。 组件化：把页面拆分成多个组件 (component)，每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。 new Vue()的时候发生了什么合并配置：一般 Vue 都会带一些配置参数，第一步就是把这个配置参数与默认参数进行合并； 初始化生命周期， 初始化事件中心， 初始化渲染， 初始化 data、props、computed、watcher 等等 中间调用了生命周期函数，beforeCreate、created 实例挂载在DOM上是如何实现的vm._render 生成虚拟DOM vm._update 把虚拟DOM更新到页面上 render方法有什么作用vm._render 最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node，这个是 Vue2.0 相对于 1.0 的重要更新。 虚拟DOM是什么，有什么好处，如何创建其实 VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常轻量和简单的。 update方法的更新机制是什么样子的 https://ustbhuangyi.github.io/vue-analysis/assets/new-vue.png 如何将虚拟DOM更新成真实DOMpatch Vue组件的生命周期 https://ustbhuangyi.github.io/vue-analysis/assets/lifecycle.png Vue响应式的原理 响应式对象 data 的初始化主要过程也是做两件事，一个是对定义 data 函数返回对象的遍历，通过 proxy 把每一个值 vm._data.xxx 都代理到 vm.xxx 上；另一个是调用 observe 方法观测整个 data 的变化，把 data 也变成响应式，可以通过 vm._data.xxx 访问到定义 data 返回函数中对应的属性。 Observer 是一个类，它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新： 一般情况下，都是在初始化组件的时候会把我们定义的数据转化成“可观测对象”，所以我们如果给data里面的对象添加一条属性，这个属性不会在页面上刷新。 依赖收集 收集依赖的目的是为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理，主要是 Watcher 和 Dep，核心思想就是使用 getter() 派发更新 就是当数据发生变化的时候，触发 setter 逻辑，把在依赖过程中订阅的的所有观察者，也就是 watcher，都触发它们的 update 过程 nextTick 有什么作用123456789for (macroTask of macroTaskQueue) &#123; // 1. Handle current MACRO-TASK handleMacroTask(); // 2. Handle all MICRO-TASK for (microTask of microTaskQueue) &#123; handleMicroTask(microTask); &#125;&#125; 数据的变化到 DOM 的重新渲染是一个异步过程。如果需要在数据变化之后取到变化后的DOM，可以使用 nextTick 方法。这个方法和React中的 this.setState 的第二个参数类似。 有没有一些情况，当你改变了数据，但是DOM没有更新 给一个对象新增属性 通过下标、length去改变数组 解决方法： 对于对象，在定义data的时候，就要把相关的属性定义好； 对于数组的更新，可以使用push、pop等方法，可以触发notify 更新的时候，赋值一个新数组或者新对象； 使用 $set 方法 使用forceUpdate","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"面试题系列之你在平时开发的时候遇到过哪些问题","slug":"interview-faq","date":"2020-09-22T16:00:00.000Z","updated":"2023-12-06T15:25:19.245Z","comments":true,"path":"2020/09/23/interview-faq/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/09/23/interview-faq/","excerpt":"","text":"面试的时候遇到这个问题，我们要先考虑这个问题的意图是什么，是要考察你哪些方面的能力。 你的沟通能力，表达能力 技术能力（业务难题，技术难题） 领导能力（团队资源协调，总结，分享，成长） 下面是根据我自身职业的需要列出来的回答： 代码规范问题维护了很长一段时间的旧代码，这个我觉得是几乎所有企业都会有的问题，就是一些旧代码很难维护，逻辑、文档、规范等等，对于需要长期使用的代码，有很多维护的成本。对于代码规范，我把ESLint带进了我们的公司，像缩进、空格、引号、ES6简写等等，这些规范可以节约大量的维护成本。 本来是想把这个检验的步骤放到编译平台的，但是由于老项目特别多，所以只是在本地去进行。其实我第一家公司把ESLint写到编译平台上了，不符合规则的时候，直接不允许编译通过。 兼容CSS3、ES6我之前也说了，我维护了很长一段时间的旧代码，有时候在旧代码的基础上开发的时候，我想用一些相对比较新的技术，例如CSS3、ES6，就会发现，有些低版本的手机不支持。以前解决这个问题的方法就是不使用CSS3、ES6，但是我在ESLint上面引用了ES6的规范，造成了一个冲突。 解决方法就是在自动化编译平台里面，使用Gulp把所有JS文件进行了编译操作。对于CSS3的浏览器厂商前缀，我也是用gulp写了一个配置，处理所有的CSS文件。 全局修改或兼容旧版本发现了代码优化空间在全局位置维护一个全局配置常量，例如，币种以前是0、1、2对应人民币、美元、港币，现在突然改成CNY、USD、HKD，我在改的时候发现所有用到的地方都要改，此时我就在全局位置写了一个常量，这样以后如果有修改的话，只需要改一个地方。另外，就是让代码语义化。我们直接在代码里写0、1、2，这个就叫做魔术数字。 更新规范的问题我们有个老项目用到的是版本很早的jQuery，然后客户在做安全监测的时候发现了一些漏洞，然后就要替换成更新版本的jQuery。结果发现代码里其他地方用到了一些只有低版本jQuery才有的方法，导致更新之后有很多报错。比如$(ele).size() 然后平时工作中也会遇到类似的问题，就是后端更新之后，导致一些功能无法正常运行。随后我们就制定了一个更新的规范，每次更新都要包含：新增了哪些功能，修改了哪些功能，删除了哪些功能，即将删除哪些功能。针对即将删除的功能，要提前对影响范围作出改造优化的计划。 技术和实现的问题，总会有解决方案。人员的沟通、协调、遵守规范，其实占用了更多的时间。 其实，这个问题没有必要用各种高深的技术来回答，任何自己做过的优化或者解决的问题都可以拿出来分享一下，关键在于解决的过程、收获的描述。","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"如何维护更新日志","slug":"change-log","date":"2020-09-21T16:00:00.000Z","updated":"2023-12-06T15:25:19.243Z","comments":true,"path":"2020/09/22/change-log/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/09/22/change-log/","excerpt":"","text":"更新日志是什么更新日志不是Git提交记录的累加。 更新日志（Change Log）是一个由人工编辑，以时间为倒序的列表， 以记录一个项目中所有版本的显著变动。 为什么要提供更新日志为了让用户和开发人员更简单明确的知晓项目在不同版本之间有哪些显著变动。 哪些人需要更新日志人人需要更新日志。无论是消费者还是开发者，软件的最终用户都关心软件所包含什么。 当软件有所变动时，大家希望知道改动是为何、以及如何进行的 怎样制作高质量的更新日志指导原则 记住日志是写给人的，而非机器。 每个版本都应该有独立的入口。 同类改动应该分组放置。 版本与章节应该相互对应。 新版本在前，旧版本在后。 应包括每个版本的发布日期。 注明是否遵守语义化版本格式。 变动类型 Added 新添加的功能。 Changed 对现有功能的变更。 Deprecated 已经不建议使用，准备很快移除的功能。 Removed 已经移除的功能。 Fixed 对bug的修复 Security 对安全的改进 如何减少维护更新日志的精力在文档最上方提供 Unreleased 区块以记录即将发布的更新内容。 这样有两大意义： 大家可以知道在未来版本中可能会有哪些变更 在发布新版本时，可以直接将Unreleased区块中的内容移动至新发 布版本的描述区块就可以了 有很糟糕的更新日志吗 使用git日志：git日志充满各种无意义的信息， 如合并提交、语焉不详的提交标题、文档更新等。提交的目的是记录源码的演化。 一些项目会清理提交记录，一些则不会；更新日志的目的则是记录重要的变更以供最终受众阅读，而记录范围通常涵盖多次提交。 无视即将弃用功能：当从一个版本升级至另一个时，人们应清楚（尽管痛苦）的知道哪些部分将出现问题。 应该允许先升级至一个列出哪些功能将会被弃用的版本，待去掉那些不再支持的部分后， 再升级至把那些弃用功能真正移除的版本。即使其他什么都不做，也要在更新日志中列出derecations，removals以及其他重大变动。 易混淆的日期格式：2012-06-02不与其他日期格式相混淆，而且还 符合ISO标准（yyyy-MM-dd）。 例子123456789101112131415161718192021222324252627282930313233343536373839404142## [0.0.5] - 2015-02-16### Added- Link, and make it obvious that date format is ISO 8601.### Changed- Clarified the section on \"Is there a standard change log format?\".### Fixed- Fix Markdown links to tag comparison URL with footnote-style links.## [0.0.4] - 2014-08-09### Added- Better explanation of the difference between the file (\"CHANGELOG\")and its function \"the change log\".### Changed- Refer to a \"change log\" instead of a \"CHANGELOG\" throughout the siteto differentiate between the file and the purpose of the file — thelogging of changes.### Removed- Remove empty sections from CHANGELOG, they occupy too much space andcreate too much noise in the file. People will have to assume that themissing sections were intentionally left out because they contained nonotable changes.## [0.0.3] - 2014-08-09### Added- \"Why should I care?\" section mentioning The Changelog podcast.## [0.0.2] - 2014-07-10### Added- Explanation of the recommended reverse chronological release ordering.## [0.0.1] - 2014-05-31### Added- This CHANGELOG file to hopefully serve as an evolving example of a standardized open source project CHANGELOG.- CNAME file to enable GitHub Pages custom domain- README now contains answers to common questions about CHANGELOGs- Good examples and basic guidelines, including proper date formatting.- Counter-examples: \"What makes unicorns cry?\" 参考资料：https://keepachangelog.com/","categories":[{"name":"其他","slug":"其他","permalink":"https://github.com/beat-the-buzzer/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://github.com/beat-the-buzzer/tags/Git/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://github.com/beat-the-buzzer/tags/MarkDown/"}]},{"title":"防抖节流操作总结","slug":"debounce-throttle","date":"2020-09-11T16:00:00.000Z","updated":"2023-12-06T15:25:19.243Z","comments":true,"path":"2020/09/12/debounce-throttle/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/09/12/debounce-throttle/","excerpt":"","text":"防抖和节流是我们平时开发的时候非常常见的一个功能，比如，按钮点击提交表单、输入框变化的时候需要发请求、浏览器窗口发生变化的时候做一些操作等等。每次用户快速操作的时候，经常会出现一些问题，比如重复提交等等，这个时候我们就需要对这样的业务场景进行优化。 一般我们的优化方式就是防抖和节流。 防抖节流概念所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。 所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。 下面介绍几个常见的例子来帮助理解防抖节流的概念。 输入框变化发请求1&lt;input type=\"text\" onchange=\"changeInput(this.value)\" /&gt; 我们如果不做任何处理的话，每次输入一个字符，就会去触发这个函数，然后发请求，渲染页面。发请求的操作还有可能出现异步的情况，就是先发的请求后返回，导致页面渲染错误。事实上，我们如果快速输入了四个字符，前三次其实是没有必要去执行的。 1234567891011var timeout;// 下面的代码应该是在输入框改变的时候触发if(timeout) &#123; // 如果有一个方法正在等待执行，就直接清理掉，因为这个是没有必要执行的 后面会新建一个新的 clearTimeout(timeout);&#125;// 最新的执行队列，一秒内如果没有输入，就执行timeout = setTimeout(function() &#123; changeInput();&#125;, 1000); 这两种方法就是防抖。如果你一直快速输入，持续10秒，那么只会执行最后一次。 按钮的防重复点击1&lt;button onclick=\"submit\"&gt;提交&lt;/button&gt; 很显然，我们不希望在提交表单的时候发多次请求，事实上，如果我们不做任何处理，在快速点击的时候，就会多次执行submit方法。 下面这个方法就是在第点击，提交方法执行的同时把状态变成不可操作，然后一秒之后再重置，这样的话，用户就不可能再一秒内提交两次。 1234567891011var flag = true; // 表示按钮可以点击，可以提交表单// 下面的代码应该是在点击的时候去执行if(flag) &#123; var flag = false; // 在执行submit之前，先把状态改成不可点击 submit(); // 一秒之后才可以再次提交 setTimeout(function() &#123; flag = true; &#125;, 1000)&#125; 还有一种思路是用两次点击的时间来进行计算，计算点击的瞬间的时间和上次点击时间的间隔，如果超过一定值，我们才允许函数执行。 12345678var pre = 0;// 下面的代码应该是在点击的时候去执行var now = Date.now();if(now - pre &gt; 1000) &#123; pre = now; submit()&#125; 这两种方法就是节流。如果你每0.1秒点击一次，不做节流处理的情况下，10秒就需要执行100次。做了节流操作之后，一秒最多执行一次，10秒最多执行10次。 总结：防抖是减小执行数量，节流是减小执行频率。 逐步优化上面的几种方法解决了我们开发过程中遇到的实际问题，但是，我们不能仅仅满足于解决问题，还需要考虑通用的方案，把防抖和节流做成公共方法。我们要避免复制代码，要多复用代码。 之前有一篇文章，讲的是函数式编程，这个可以完美解决我们的问题，我们的目标是把我们原本调用的changeInput、submit改成func(changeInput)、func(submit)这样的形式。func就是我们的公共方法，在其他地方直接调用就行，不用复制防抖和节流的具体实现。参考文章：函数式编程 函数入参：执行函数、时间间隔。 执行函数就是我们原本要绑定的事件，在上面的例子中就是changeInput和submit，时间间隔应该是可传的参数，我们可以给个默认值。 函数返回：一个新的函数，用法、参数和changeInput、submit一样。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 防抖函数function debounce(func, wait=1000) &#123; var timeout; return function() &#123; var that = this; // 函数的执行上下文 var args = [].slice.call(arguments); // 函数的参数转成数组 if(timeout) &#123; clearTimeout(timeout); &#125; timeout = setTimeout(function() &#123; func.apply(that, args); // 这里的this是函数调用时的上下文 &#125;, wait); &#125;&#125;// 节流函数1function throttle1(func, wait = 1000) &#123; var flag = true; return function() &#123; var that = this; var args = [].slice.call(arguments); if(flag) &#123; flag = false; func.apply(that, args); setTimeout(function() &#123; flag = true; &#125;, wait) &#125; &#125;&#125;// 节流函数2function throttle2(func, wait = 1000) &#123; var pre = 0; return function() &#123; var now = Date.now(); var that = this; var args = [].slice.call(arguments); if(now - pre &gt; wait) &#123; pre = now; func.apply(that, args); &#125; &#125;&#125; 经过上面的改造之后，我们就可以在项目中使用这些公共方法了：obj = { } 123&lt;input type=\"text\" onchange=\"debounce(changeInput, 1500)(this.value)\" /&gt;&lt;button onclick=\"throttle1(submit)\"&gt;提交&lt;/button&gt;&lt;button onclick=\"throttle2(submit, 2000)\"&gt;提交&lt;/button&gt; 至此，一个公共方法就完成了。 其实我们还可以进一步进行封装，比如我们使用Vue或者React的时候，可以自己对button组件进行封装，新增参数控制是否需要防抖节流，这样，我们就可以直接在组件内部解决了这个问题。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://github.com/beat-the-buzzer/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"移动端适配之淘宝方案分析","slug":"mobile-adaptation","date":"2020-08-25T16:00:00.000Z","updated":"2023-12-06T15:25:19.246Z","comments":true,"path":"2020/08/26/mobile-adaptation/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/08/26/mobile-adaptation/","excerpt":"","text":"这里主要是对淘宝适配方案：flexible进行源码分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143// 封装全局对象的常用方法，减少变量污染; (function (win, lib) &#123; var doc = win.document; var docEl = doc.documentElement; var metaEl = doc.querySelector('meta[name=\"viewport\"]'); // 获取标签推荐使用querySelector var flexibleEl = doc.querySelector('meta[name=\"flexible\"]'); var dpr = 0; var scale = 0; var tid; var flexible = lib.flexible || (lib.flexible = &#123;&#125;); // doc取文档的document对象 // docEl取到了我们html为根的整个dom树，后期我们需要向html插入dpr和font-size就是用这个属性 // metaEl取meta标签里面name＝viewport的元素，没有返回空，为了判断是否有自己设置的meta值来做一些逻辑 // flexibleEl取meta标签里面name＝flexible的元素，没有返回空，为了判断用户是否自己手动的设置了一些meta值 // dpr表示的是取你手机屏幕的dpr值 设备像素比 // scale表示取你meta里面的scale，会根据不同的scale设置dpr // 先定义好变量，尤其是获取dom元素的地方，都要缓存在变量里，不推荐每次都用document.documentElement去访问DOM if (metaEl) &#123; // 如果设置了meta viewport，就读取设置的缩放比例 console.warn('将根据已有的meta标签来设置缩放比例'); var match = metaEl.getAttribute('content').match(/initial\\-scale=([\\d\\.]+)/); if (match) &#123; scale = parseFloat(match[1]); dpr = parseInt(1 / scale); &#125; &#125; else if (flexibleEl) &#123; // 如果设置了meta flexible var content = flexibleEl.getAttribute('content'); if (content) &#123; var initialDpr = content.match(/initial\\-dpr=([\\d\\.]+)/); var maximumDpr = content.match(/maximum\\-dpr=([\\d\\.]+)/); if (initialDpr) &#123; dpr = parseFloat(initialDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; if (maximumDpr) &#123; dpr = parseFloat(maximumDpr[1]); scale = parseFloat((1 / dpr).toFixed(2)); &#125; &#125; &#125; // 如果没有获取到了这两个值，就使用系统参数获取到的设备像素比 if (!dpr &amp;&amp; !scale) &#123; var isAndroid = win.navigator.appVersion.match(/android/gi); var isIPhone = win.navigator.appVersion.match(/iphone/gi); var devicePixelRatio = win.devicePixelRatio; if (isIPhone) &#123; // iOS下，对于2和3的屏，用2倍的方案，其余的用1倍方案 if (devicePixelRatio &gt;= 3 &amp;&amp; (!dpr || dpr &gt;= 3)) &#123; dpr = 3; &#125; else if (devicePixelRatio &gt;= 2 &amp;&amp; (!dpr || dpr &gt;= 2)) &#123; dpr = 2; &#125; else &#123; dpr = 1; &#125; &#125; else &#123; // 其他设备下，仍旧使用1倍的方案 dpr = 1; &#125; scale = 1 / dpr; // 这一行十分关键，如果是2倍屏，一切都放大两倍的时候，由于这一行的存在 &#125; docEl.setAttribute('data-dpr', dpr); // 这个设置，可以用于定义不同的样式，如果没有动态修改initial-scale 其实也不需要动态修改 if (!metaEl) &#123; metaEl = doc.createElement('meta'); metaEl.setAttribute('name', 'viewport'); metaEl.setAttribute('content', 'initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); if (docEl.firstElementChild) &#123; docEl.firstElementChild.appendChild(metaEl); &#125; else &#123; var wrap = doc.createElement('div'); wrap.appendChild(metaEl); doc.write(wrap.innerHTML); &#125; &#125; // 当我们之前没有设置metaEl标签的话，那么需要我们手动的去创建meta标签，实现移动端的适配，也就是创建一个默认的meta function refreshRem() &#123; var width = docEl.getBoundingClientRect().width; if (width / dpr &gt; 540) &#123; width = 540 * dpr; &#125; var rem = width / 10; // 意味着100%的宽度就是10rem docEl.style.fontSize = rem + 'px'; flexible.rem = win.rem = rem; &#125; // 屏幕宽度发生改变的时候，重新设置根元素的font-size win.addEventListener('resize', function () &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125;, false); win.addEventListener('pageshow', function (e) &#123; if (e.persisted) &#123; clearTimeout(tid); tid = setTimeout(refreshRem, 300); &#125; &#125;, false); // 监听window里面的resize和pageshow方法来实现css样式的重绘 if (doc.readyState === 'complete') &#123; doc.body.style.fontSize = 12 * dpr + 'px'; &#125; else &#123; doc.addEventListener('DOMContentLoaded', function (e) &#123; doc.body.style.fontSize = 12 * dpr + 'px'; &#125;, false); &#125; // 设置body的font-size，是为了给页面元素一个初始的font-size refreshRem(); flexible.dpr = win.dpr = dpr; flexible.refreshRem = refreshRem; flexible.rem2px = function (d) &#123; var val = parseFloat(d) * this.rem; if (typeof d === 'string' &amp;&amp; d.match(/rem$/)) &#123; val += 'px'; &#125; return val; &#125; flexible.px2rem = function (d) &#123; var val = parseFloat(d) / this.rem; if (typeof d === 'string' &amp;&amp; d.match(/px$/)) &#123; val += 'rem'; &#125; return val; &#125;&#125;)(window, window['lib'] || (window['lib'] = &#123;&#125;)); 从代码里我们可以看到，这里dpr的值就是viewport中的initial-scale属性，一般情况下，这个值是不会变的。 最终我们得到的结果就是，根据屏幕宽度，动态计算出了根元素的font-size值。 当然，我们还有其他的方法动态修改根元素的font-size： 媒体查询 优点：CSS的方式，不会出现闪动 缺点：代码冗余，适配不够精确 用calc(vw / x)计算 优点：简单、代码量少 缺点：需要支持vm（未来会逐步支持）","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://github.com/beat-the-buzzer/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"https://github.com/beat-the-buzzer/tags/CSS3/"},{"name":"移动端适配","slug":"移动端适配","permalink":"https://github.com/beat-the-buzzer/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"移动端适配前置知识学习","slug":"pre-mobile-adaptation","date":"2020-08-25T16:00:00.000Z","updated":"2023-12-06T15:25:19.246Z","comments":true,"path":"2020/08/26/pre-mobile-adaptation/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/08/26/pre-mobile-adaptation/","excerpt":"","text":"什么是移动端适配？ 移动端页面，常见的有webview的H5页面，手机浏览器端的页面等等；目的是在不同尺寸的手机设备上，页面“相对性的达到合理的展示（自适应）”或者“保持统一效果的等比缩放（看起来差不多）”。 在讲移动端适配之前，我们需要弄清楚一些基本的概念。 viewport参考资料： https://www.cnblogs.com/2050/p/3877280.html#!comments 123456visual viewport：可见视口，即屏幕宽度；layout viewport：布局视口，即DOM宽度；idea viewport：理想适口，使布局视口就是可见视口；设备宽度（visual viewport）与DOM宽度（layout viewport），scale的关系是：（visual viewport）&#x3D; （layout viewport）* scale获取屏幕宽度（visual viewport）的尺寸：window.innerWidth&#x2F;Height获取DOM宽度（layout viewport）的尺寸：document.documentElement.clientWidth&#x2F;Height 移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图列出了一些设备上浏览器的默认viewport的宽度。 https://images0.cnblogs.com/blog/130623/201407/300958475557219.png 我们新建一个空的html文件，里面什么都不加，把body的宽度设置为100vw，在浏览器的iPhone模式下查看，发现body的实际宽度是980px。实际上，真正的iPhone(以iPhone 6/7/8)为例，实际屏幕的宽度只有375px。如果我们什么都不做，直接开发页面，就会出现横向滚动条，这个明显是不好的体验。 像素 CSS像素、物理像素、逻辑像素、设备像素比参考资料：https://github.com/jawil/blog/issues/21 CSS中的px和设备中的px是不一样的。在iphone3，它的分辨率为320x480，此时css像素和设备的物理像素是一样的。iphone4开始，分辨率变成640x960，但屏幕尺寸却没变化，此时css中的1px可以展示两个物理像素，这样，屏幕上的元素会变得更清晰。 逻辑像素可以看做是CSS中的像素，物理像素代表的是设备内部计算使用的像素。 window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。 用meta标签1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"&gt; 属性 定义 width 设置layout viewport 的宽度，为一个正整数，或字符串”width-device” initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 height 设置layout viewport 的高度，这个属性对我们并不重要，很少使用 user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许 1234567屏幕尺寸、屏幕分辨率--&gt;对角线分辨率&#x2F;屏幕尺寸--&gt;屏幕像素密度PPI | 设备像素比dpr &#x3D; 物理像素 &#x2F; 设备独立像素dip(dp) | viewport: scale | CSS像素px 字体大小的控制首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理，ppk把这个viewport叫做 ideal viewport，也就是第三个viewport——移动设备的理想viewport。 RemRem是一个相对的长度单位，’R’是root的意思，也就是相对于根元素的字体大小来计算长度。如果我们让根元素和屏幕宽度有一个对应关系，那么我们的间距、字体等等任何使用Rem做单位的值，都会和屏幕宽度有对应关系，其实移动端适配的核心思想就在这里。 争议：字体是否需要使用Rem? 从我实际的使用效果来看，字体大小使用Rem做单位是没有太多问题的，可以满足平时的开发需求。 小结适配不同屏幕宽度以及不同dpr，通过动态设置viewport(scale=1/dpr) + 根元素fontSize + rem, 辅助使用vw/vh等来达到适合的显示； 若无需适配可显示1px线条，也可以不动态设置scale，只使用动态设置根元素fontSize + rem + 理想视口； 当视口缩放，计算所得的根元素fontSize也会跟着缩放，即若理想视口(scale=1), iPhone6根元素fontSize=16px; 若scale=0.5, iPhone6根元素fontSize=32px; 因此不必担心rem的计算； 全部用rem即可，包括字体大小，不用px； px为单位的元素，需根据dpr有不同的大小，如大小12px, dpr=2则采用24px, 使用sass mixin简化写法； 配合scss函数，简化px2rem转换，且易于维护(若需修改$base-font-size, 无需手动重新计算所有rem单位)； px2rem函数的base-font-size=32px，参数传值直接为设计图标注尺寸； 使用iPhone6(375pt)二倍设计图:宽度750px； 切图使用三倍精度图，以适应三倍屏 参考资料 https://www.jianshu.com/p/b13d811a6a76","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://github.com/beat-the-buzzer/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"https://github.com/beat-the-buzzer/tags/CSS3/"},{"name":"移动端适配","slug":"移动端适配","permalink":"https://github.com/beat-the-buzzer/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"}]},{"title":"Git撤销操作汇总","slug":"git-rescind","date":"2020-07-29T16:00:00.000Z","updated":"2023-12-06T15:25:19.244Z","comments":true,"path":"2020/07/30/git-rescind/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/07/30/git-rescind/","excerpt":"","text":"在任何一个阶段，你都有可能想要撤消某些操作。Ctrl ACV 我们很常用，Ctrl Z 使用频率也很高。同理，Git上的操作我们也经常需要去撤销一些操作，下面就简单总结一下。 撤销修改撤销修改，其实就是把代码回退到没有修改之前的状态，其实就是VSCode上面的那个撤销按钮。不过VSCode在内部做了判断：如果本次修改是新增一个文件，那么撤销按钮点击后，就执行删除操作；如果本次修改是删除或者修改了一个文件，点击撤销按钮的时候，就是从本地仓库里恢复文件； 撤销修改 1git checkout [filename] 这里要注意的事情就是checkout这个命令，我们熟知的是用于切换分支，所以对于撤销修改这个操作，我们可能不太熟悉。 撤销暂存这个在VSCode里面也有自带的快捷按钮，这个命令可以说是git add 的反向操作，就是把文件从暂存区里面拿出来。 撤销暂存 1git reset HEAD [filename] 提交信息的撤销1git commit --amend 这个命令也算是一种撤销，只不过撤销的是提交信息。比如，我们修改了一个bug，改了3个文件，并且已经提交了。突然我们发现漏提交了一个文件，这个时候，假设我们走正常的提交流程，就会多创建了一个提交，我们就不能一次性地看到这个bug修改了哪些文件。此时我们可以使用上面这个命令，可以编辑上一次提交的日志，也可以说是撤销重新提交。 提交到本地仓库之后的回退两种回退方式：reset和revert。 reset回滚的时候，可以看做版本指针移动到指定位置，这个位置后面的提交都会被丢失； reset操作 12345git reset --hard HEAD^ # 回退到上一个版本git reset --hard HEAD^^ # 回退到上上一个版本git reset --hard HEAD~100 # 回退到前100一个版本git log # 获取提交日志git reset --hard [commit-hash] # 回退到指定的那次提交 revert 是回滚某次提交，创建了一次新的提交，这次提交改动的内容就是还原了那次提交改变的东西。 revert操作 1234git log # 获取提交日志git revert -n [commit-hash] # 这次提交的东西没了git add # 后续提交git commit -m \"\" revert 是回滚某个 commit ，reset是回滚“到”某个 commit 之后的状态 推送到远程之后的回退上面已经使用了reset和revert，接下来我们只需要推送到远程就行了。 如果是reset命令，当前回退后的版本低于线上版本，因此直接提交会报错，此时需要强制提交到远程： 1git push -f 如果是revert命令，当前版本是一次新的提交，直接push就可以了： 1git push","categories":[{"name":"其他","slug":"其他","permalink":"https://github.com/beat-the-buzzer/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://github.com/beat-the-buzzer/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://github.com/beat-the-buzzer/tags/GitHub/"}]},{"title":"读书笔记系列——沟通心理学","slug":"booklist-c11n-p8y","date":"2020-07-27T16:00:00.000Z","updated":"2023-12-06T15:25:19.243Z","comments":true,"path":"2020/07/28/booklist-c11n-p8y/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/07/28/booklist-c11n-p8y/","excerpt":"","text":"文件名 booklist-communication-psychology 对于超长单词的简写方式：c11n p8y，11和8意味着中间省略了 11个和 8个字母。 一、沟通前先心理热身， 没有谈不成的事、聊不来的人同理心：感情的共鸣是沟通的润滑剂所谓同理心，就是能够设身处地为他人着想的态度和思路。 同理心的理解有三种：一是尝试采用另一个人的观点，将自己的意见放在一边，同时试着去了解对方；二是贴近地去体验别人的感受；三是真诚地关心对方的福祉。 影响沟通的重要因素包括心理、情绪、态度和感受。对待沟通，有句话很重要：先处理心情，再处理事情。 从众心理：从众，让人不假思索地认同你所谓从众心理，指的是人们在受到其他人或者其他人群的行为影响之后，不由自主地改变自己的心理状态，最终做出符合大众要求的选择。 很多情况下，人们完全是在不知不觉中受到从众心理的影响，就是”随大流“。 在过马路的时候，如果大家都遵守交通规则，就不会有人闯红灯；如果有个人带头闯红灯，就会有很多人跃跃欲试，甚至紧随其后。 人们总是怀着侥幸心理，觉得法不责众，因而丝毫不担心为此会受到责罚，这个是从众心理的负面作用。 很多情况下，我们可以通过深入了解和灵活运用从众心理，达成自己的目标，最终得到自己想要的结果，但是任何事情都是有两面性的，我们要保持理智的思考，从而做出正确的选择。 折中心理：一切能否如你预期的那般所谓折中心理，其实就是一种让步心理。 把握好这种心理，就能够在沟通的时候让自己处于主动的位置，提前预判对方下一步的心理活动。 如果我们先知先觉，掌握好这种心理，就能控制自己的沟通情绪，影响或者引导他人的沟通情绪，使自己在这场语言的博弈之中处于有利位置。 猎奇心理：与其求着听，不如晾着说所谓猎奇心理，通俗地说，就是好奇心。每个人都有好奇心，为了满足好奇心，人们总是想方设法地想要了解真相。 猎奇心理虽然是好奇心，但是依然与好奇心有明显的差别：好奇心是天生的本能，猎奇心理有强迫的意味。不是他人强迫，而是我们在好奇心的驱使下强迫自己。所以猎奇心理比好奇心更加强烈、更难以控制。 虚荣心理：满足虚荣心，沟通更顺畅生活中确实有很多人，对自己缺乏自信，却总是想要与他人攀比，只有比得过他人时，才能够充满自信。在与这种虚荣心强的人打交道时，我们不要随意打击他们的自信心和虚荣心，即使知道他们的虚荣心下掩藏着自卑，也不要揭穿他们，而应该顺应他们的心思，给予他们更多的赞美和鼓励。 我们在社会中难免遇到形形色色的人，只有保持一颗淡定、平和、宽容的心，我们才能接纳他人，从而帮助自己打开他人心扉，与他人建立友好交往的平台。换一个角度说，当你对他人吹毛求疵时，必然会给自己带来无尽的痛苦。 优越心理：让人们不再斤斤计较的秘诀所谓优越心理，顾名思义，就是觉得自己比他人强大的心理，也表现在自己的各方面条件比他人好。 在这种心理的影响下，人们往往自高自大，这会限制个人的发展，但是优越心理也有积极的一面，那就是当一个人高高在上地对待另一个人时，他就会变得很宽容，不会斤斤计较。 成全别人的优越感，是良好的沟通手段。可以从两方面入手： 一是降低姿态，谦虚处事。 二是赞美对方，和谐气氛。 互惠心理：一举两得，何乐而不为在工作和生活中，几乎没有任何人能够仅凭一己之力，就能完美地完成很多事情，因而我们必须要学会求助于他人，尤其是在遭到他人拒绝时，我们要做的不是放弃，而是找出对对方有利的事情，与对方互惠互利。 他们心中普遍有这样的想法：给予是一种责任，接受是一种责任，偿还也是一种责任。偿还的责任不仅减弱了我们选择施恩者的能力，还把这种权利交到了对方的手里。 尤其是在现代社会的职场，人情越来越淡漠，很多人之间的交往都是建立在利益的基础上，这其实无可厚非。没有永远的敌人，只有永远的利益。如果我们与他人成为利益共同体，通过同一件事情结盟，那么我们与他人的关系就会变得坚不可摧。在这个基础上，我们请求他人帮助会显得理所当然。 抓住对方的互惠心理，就不会在交际沟通中惨遭拒绝，而是让对方欣然接受你的请求； 一个人硬塞给我们的好处，也一样容易触发我们的亏欠感，互惠原理已经在人们心中成为了思维定式； 人们为了消除令人不安的亏欠感，往往会付出比先前所得恩惠大得多的恩惠作为自己的回报。 权威心理：专家让人站一队，权威更有说服力在企业中，领导可以利用”权威效应“去引导或者改变下属的工作态度，提高工作效率，这往往比命令的效果更好。 在教育中，尤其是在课堂管理的过程中，教师对于学生而言是”权威人物“，不论是专业知识还是人生阅历都有绝对的优势。教师可以利用这一点，在学生中确立自己的权威。 在与他人沟通的时候，适时地引用专业人士的言论更能使人信服。 二、顺畅沟通，牢记八大基本原则人际交往的基础，尊重心态不能少良好沟通的前提，微笑以对很重要适时倾听姿态好，然后发声效果妙浮躁心态不可取，耐心更能动人心良言一句三冬暖，恶语伤人六月寒营造良好的氛围，交谈才能获双赢察言观色再发声，有效沟通巧促成话题找对是关键，让沟通事半功倍 三、读懂肢体语言，让对方传递出的信号为自己所用读懂眼神，才能探查人心适时点头，表达关注与欣赏频频点头，也许意味着厌烦与催促水杯摆放，位置丈量心理距离座位变动，助你不动神色施压于人脚尖指向，窥探他人心理秘密频繁看表，暗示应该结束谈话 四、攻心有术，用正确的钥匙打开心门上的锁运用正确的称谓，拉进彼此的距离","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"阅读","slug":"阅读","permalink":"https://github.com/beat-the-buzzer/tags/%E9%98%85%E8%AF%BB/"},{"name":"心理学","slug":"心理学","permalink":"https://github.com/beat-the-buzzer/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"面试题系列之常见非技术问题","slug":"interview-non-technical","date":"2020-07-26T16:00:00.000Z","updated":"2023-12-06T15:25:19.245Z","comments":true,"path":"2020/07/27/interview-non-technical/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/07/27/interview-non-technical/","excerpt":"","text":"面试的时候，要提前做好充分的准备，不仅仅是技术方面，还有项目经验、语言表达能力、价值观、职业规划等等。在这之前，我曾经写了一篇面试评价表：https://beat-the-buzzer.github.io/2020/05/27/interview-set/，总结了面试的一些考察点。 简历关键点：联系方式、技术栈、项目。 联系方式，手机和邮箱格外重要。一般发offer都会发给你的邮箱，面试结果、重要通知，基本上都会电话通知； 技术栈是在简历筛选阶段起到重要作用。HR会看技术栈是否和公司现有的技术匹配，毕竟是社招，很少给你时间去学习一段时间，大家都是成熟的开发者了，该学会独立工作了；不过要理解什么是技术栈，我之前看了一些简历，里面写了很多第三方插件的使用，mescroll、swiper、axios等等，我个人觉得这些不该出现在技术栈这一栏。 项目经历也是其中的一个重点，因为现在的产品种类特别多，webApp、PC、PC客户端、微信小程序、支付宝小程序等等，我们的项目经历也是极其重要的。 简历亮点：从大千世界中脱颖而出 阅读框架源码，永远比用过N中不同的框架强太多； 源码候选：flexible、clipborad、Vue、React 阅读源码有哪些收获？ 封装组件的通用方法，立即执行函数，减少变量污染； 如何兼容处理，比如我经常需要兼容App和H5，我可以从中学到一些兼容类的技巧，比如优雅降级和渐进增强的思想。支持复制粘贴的那个方法的，就是用这个方法，如果不支持，就退而求其次，选中文字，然后弹出提示：按ctrl+c复制； Vue和React的源码我都仔细看过了，包括一些衍生的Vuex，Vue-Router，React-Redux，Mobx，React-Router-Dom等等。我们的目的不仅仅是使用框架解决实际问题，更大的目的是深入原理，举一反三，从而解决更多的问题。 GitHub、个人博客，技术岗位的必备之选； 其实最完美的学习方法，就是把一个技术或者知识点，讲述出来，让别人听懂，自己温故知新。 读书，任何方面的书，技术，非技术，通识课程。 自我介绍技术栈、工作经历、项目经历、遇到的问题，解决方法 工作成果介绍 技术等级的提升 面试新员工 新员工入职指导 公共组件库的维护 分享会的组织 参与和执行项目重构 项目介绍 投资堂App 这个是公司自己的产品，主要包括了股票行情交易的基础业务，这些业务可能会作为证券公司的参考。是原生和H5的混合开发，我负责的模块主要是交易柜台的兼容修改；旧模块的重构，jQuery重构成Vue；新需求开发，股转改革和创业板改革；增值业务的开发，会员中心、积分系统等等；主要用到的前端框架是Vue； PC行情交易 这个是Vue开发的PC端项目，主要有行情和交易两个大模块，行情模块就是展示股票的价格、走势等等，有分时图、K线图等等；交易模块就是股票的买卖、查询、持仓、转账等功能；用到的技术是Vue和ElementUI。 自动化编译平台 这个是公司内部使用的自动化编译平台，可以编译C++、Java、Python、Android、iOS、H5、UI图等等。我主要负责的模块，就是写一些Gulp方法去处理对应的文件，比如ES6转ES5、CSS自动新增浏览器前缀、HTML/CSS/JS压缩等等。读取.gitlab-ci.yml里面的配置，比如，PC端项目和移动端项目的CSS前缀不一样，这个可以通过读取配置的方式选择不同的browserslist。 TZT-UI 这个是公司内部使用的UI框架。平常负责对公共组件进行一些升级、维护。比如，把按钮、弹窗的样式改成公司通用的UI样式；对组件进行二次封装，比如封装起止日期的组件；新增平常开发中会用到的公共组件；对现有组件新增新的功能，比如对按钮新增放重复提交的配置；维护一个Demo项目，一方面是给UI测试效果，另一方面是提供一个文档和调用方式，就和antd-design类似。 外汇管家系统 公司自营产品，jQuery转React Mobx，正好经历了新技术选型重构，jQuery 转 React Redux。使用 WebSocket 来推送改变的外汇牌价信息。 X-Funds 银行类外汇、期权基础业务的集合项目，公司自营产品，jQuery 转 React Mobx。 职业规划职业规划也是面试过程中非常常见的问题。未来几年的计划，可以看出一个人的稳定性和成长性。 技术方面： 前端基础深入学习 源码解读，了解代码思想 前端工程化 node学习 其他方面 语言表达 沟通协调 提升工作效率 情绪管理 规范制定 一般我们的职业都是：前端开发工程师，Java开发工程师等等，我们最终都要用工程师的思想去做事：编写可维护的代码，参与规范的制定来提升团队的开发效率，熟练了解业务，遇到的问题可以提出合理的解决方案，面试、指导新员工，技术分享与提升等等。 任何一个开发岗位，其实都是一个综合性很强的职业，不仅仅是写代码而已。可能在实习阶段，做的东西有限，但是随着经验和技术的提升，我们最终做的事情，本质上都是为了更好地解决实际问题，所以我的职业规划就是一直为了这个而努力。 最后还有什么问题For技术 公司现有的开发技术框架有哪些，是否会根据开发趋势和业务需要对项目进行重构？ 对于一些老项目，是否有重构的计划，比如jQuery项目，Vue 2.0之后会出3.0，会不会进行重构？ 其实我觉得重构的不是技术，而是逻辑。就算是jQuery项目，我们依旧可以写出可维护的代码。代码最后难以维护，主要原因不在于框架本身，更多的是在于代码质量。为了提升代码质量，做了哪些事情？是否审查代码质量？是否审查代码结构，实现方式。是否监督代码？之前我们每周都会有代码评审环境，但实际只是走个形式，没有实质上的变化。 For提升 我们在平时的工作中可以获得哪些方面的提升 是否有技术分享，除了自己的专业技术，是否有其他方面的技术分享，例如，我参加过一些UI设计思想的分享会，UI会讲述他们的设计思路。因为有的时候，UI图不能完全反应出设计思路。 是否有业务培训 对一些开发阶段的痛点问题，是否会去想办法解决以及如何解决。比如第一家公司的主管让我减少使用ES6、ES7语法，因为担心实习生看不懂。","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"Vue修饰符总结（下篇）","slug":"vue-decorator02","date":"2020-07-12T16:00:00.000Z","updated":"2023-12-06T15:25:19.248Z","comments":true,"path":"2020/07/13/vue-decorator02/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/07/13/vue-decorator02/","excerpt":"","text":"Demo演示地址： https://beat-the-buzzer.github.io/my-demos/#/index/my-decorator-02 Vue的修饰符为我们解决了很多通用的问题，如果我们了解这些修饰符，就能在开发的过程中节约大量的时间。 我们都知道使用v-on或者@在Vue中绑定事件，关于事件的修饰符，其实也是十分实用的。如果我们不了解这些修饰符，就会自己去写一些原生的实现方式，实际上Vue已经在内部有实现了。 下篇主要是总结一下的修饰符，都是Vue官方文档上面的。 v-bind相关修饰符.prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定。1234 &lt;!-- 绑定一个全是 attribute 的对象 --&gt;&lt;div v-bind=\"&#123; id: id, 'class': 'blue' &#125;\"&gt;blue&lt;/div&gt;&lt;!-- 通过 prop 修饰符绑定 DOM attribute --&gt;&lt;div v-bind:innerHTML.prop=\"'red'\" :className.prop=\"'red'\"&gt;&lt;/div&gt; .camel - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)下面的例子中，第二种写法是没有效果的，第三种方法可以正常展示。 123456789&lt;svg style=\"width:50px; height:50px\" :viewBox=\"viewBox\"&gt; &lt;circle cx=\"50\" cy=\"50\" r=\"50\" fill=\"#fdd\" stroke=\"none\"&gt;&lt;/circle&gt;&lt;/svg&gt;&lt;svg style=\"width:50px; height:50px\" :view-box=\"viewBox\"&gt; &lt;circle cx=\"50\" cy=\"50\" r=\"50\" fill=\"#fdd\" stroke=\"none\"&gt;&lt;/circle&gt;&lt;/svg&gt;&lt;svg style=\"width:50px; height:50px\" :view-box.camel=\"viewBox\"&gt; &lt;circle cx=\"50\" cy=\"50\" r=\"50\" fill=\"#fdd\" stroke=\"none\"&gt;&lt;/circle&gt;&lt;/svg&gt; .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器这种情况下暂时不举例说明了。 v-model相关修饰符.lazy - 取代 input 监听 change 事件12&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=\"msg\"&gt; .number - 输入字符串转为有效的数字如果这个值无法被 parseFloat() 解析，则会返回原始的值。 1&lt;input v-model.number=\"age\" type=\"number\"&gt; .trim - 输入首尾空格过滤12&lt;input v-model=\"name0\" type=\"text\" placeholder=\"请输入姓名\"&gt;&lt;input v-model.trim=\"name\" type=\"text\" placeholder=\"请输入姓名：trim\"&gt; 小结： 或许以上的总结在实际项目中可能用不到，或者我们习惯了使用原生的解决方法，例如手动阻止默认事件，但是我们的目的不仅仅只是为了了解这个知识，更多的是通过了解这些用法，来重新温习一下JS的基础，在后面，还需要去阅读源码，了解这些装饰器在底层是如何实现的，这样才能真正走上进阶之路。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://github.com/beat-the-buzzer/tags/Vue/"}]},{"title":"Vue修饰符总结（上篇）","slug":"vue-decorator01","date":"2020-06-26T16:00:00.000Z","updated":"2023-12-06T15:25:19.248Z","comments":true,"path":"2020/06/27/vue-decorator01/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/06/27/vue-decorator01/","excerpt":"","text":"Demo演示地址： https://beat-the-buzzer.github.io/my-demos/#/index/my-decorator-01 Vue的修饰符为我们解决了很多通用的问题，如果我们了解这些修饰符，就能在开发的过程中节约大量的时间。 我们都知道使用v-on或者@在Vue中绑定事件，关于事件的修饰符，其实也是十分实用的。如果我们不了解这些修饰符，就会自己去写一些原生的实现方式，实际上Vue已经在内部有实现了。 上篇主要是总结一下各种事件的修饰符，基本上都是Vue官方文档上面的。 .stop - 调用 event.stopPropagation()由于事件冒泡的机制，在点击子元素的时候，也会触发父级的点击事件。只要在绑定事件的时候加上.stop，就可以阻止事件冒泡。 1234567&lt;div @click=\"showMsg('父元素触发')\"&gt; &lt;button @click=\"showMsg('子元素触发')\"&gt;未阻止冒泡&lt;/button\"&gt;&lt;/div&gt;&lt;div @click=\"showMsg('父元素触发')\"&gt; &lt;button @click.stop=\"showMsg('子元素触发')\"&gt;阻止冒泡&lt;/button&gt;&lt;/div&gt; .prevent - 调用 event.preventDefault()用于阻止事件的默认行为，例如，当给a标签绑定事件时，加了这个修饰符会阻止默认跳转，相当于调用了event.preventDefault()方法。 12&lt;a href=\"https://github.com/beat-the-buzzer/\" @click=\"showMsg('未阻止默认')\"&gt;未阻止默认&lt;/a&gt;&lt;a href=\"https://github.com/beat-the-buzzer/\" @click.prevent=\"showMsg('阻止默认')\"&gt;阻止默认&lt;/a&gt; .capture - 添加事件侦听器时使用 capture 模式完整的事件机制是：捕获阶段–目标阶段–冒泡阶段，默认的是事件触发是从目标开始往上冒泡。当我们加了这个修饰符之后，事件触发从包含这个元素的顶层开始往下触发。 123456&lt;div @click=\"showMsg('父元素触发')\"&gt; &lt;div @click=\"showMsg('子元素触发')\"&gt;子元素先触发&lt;/div&gt;&lt;/div&gt;&lt;div @click.capture=\"showMsg('父元素触发')\"&gt; &lt;div @click=\"showMsg('子元素触发')\"&gt;父元素先触发&lt;/div&gt;&lt;/div&gt; .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调只当事件是从事件绑定的元素本身触发时才触发回调，也就是说，通过冒泡的方式不会触发点击事件。 123456&lt;div @click=\"showMsg('父元素触发')\"&gt; &lt;div @click=\"showMsg('子元素触发')\"&gt;触发两次&lt;/div&gt;&lt;/div&gt;&lt;div @click.self=\"showMsg('父元素触发')\"&gt; &lt;div @click=\"showMsg('子元素触发')\"&gt;父元素只触发父元素上面的点击&lt;/div&gt;&lt;/div&gt; .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调12&lt;input type=\"text\" @keyup.enter=\"showMsg('Enter被按下')\"&gt;&lt;input @keyup.13=\"showMsg('Enter被按下(编码13)')\"&gt; 12345678910111213141516&#x2F;&#x2F;普通键.enter.tab.delete &#x2F;&#x2F;(捕获“删除”和“退格”键).space.esc.up.down.left.right&#x2F;&#x2F;系统修饰键.ctrl.alt.meta.shift .native - 监听组件根元素的原生事件我们直接在组件上绑定一个点击事件是没有效果的，加这个修饰符可以让组件像DOM元素一样绑定事件。 12&lt;My-Component @click=\"showMsg('无法触发')\"&gt;&lt;/My-Component&gt;&lt;My-Component @click.native=\"showMsg('触发组件的点击事件')\"&gt;&lt;/My-Component&gt; .once - 只触发一次回调只能用一次，绑定了事件以后只能触发一次，第二次就不会触发。 12&lt;div @click=\"showMsg('多次触发')\"&gt;多次触发&lt;/div&gt;&lt;div @click.once=\"showMsg('只触发一次')\"&gt;只触发一次&lt;/div&gt; .left - (2.2.0) 只当点击鼠标左键时触发 .right - (2.2.0) 只当点击鼠标右键时触发 .middle - (2.2.0) 只当点击鼠标中键时触发键盘的左、中、右键点击的时候触发 123&lt;div @click.left=\"showMsg('左键点击触发')\"&gt;左键点击触发&lt;/div&gt;&lt;div @click.right=\"showMsg('右键点击触发')\"&gt;右键点击触发&lt;/div&gt;&lt;div @click.middle=\"showMsg('滚轮点击触发')\"&gt;滚轮点击触发&lt;/div&gt; 小结： 或许以上的总结在实际项目中可能用不到，或者我们习惯了使用原生的解决方法，例如手动阻止默认事件，但是我们的目的不仅仅只是为了了解这个知识，更多的是通过了解这些用法，来重新温习一下JS的基础，在后面，还需要去阅读源码，了解这些装饰器在底层是如何实现的，这样才能真正走上进阶之路。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://github.com/beat-the-buzzer/tags/Vue/"}]},{"title":"当概率论遇到心理学","slug":"probability-psychology","date":"2020-06-01T16:00:00.000Z","updated":"2023-12-06T15:25:19.246Z","comments":true,"path":"2020/06/02/probability-psychology/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/06/02/probability-psychology/","excerpt":"","text":"人的行为，是一个很好的研究素材，分析行为背后的原理，能学到很多有趣的知识。今天分享一些心理学和概率论的一些案例。 让别人先排查问题 真实案例：一个项目有安卓、iOS和H5。某次更新之后，安卓的某个功能出问题了，iOS的是正常的。此时需要排查问题：安卓说：“更新H5之前没问题，更新完就有问题了，是H5的问题。” H5说：“安卓有问题，iOS没有问题，那应该是安卓有问题。”总之，就是一个不确定问题出在哪，需要多方排查的问题。 心理分析：对于问题原因五五开的情况，很多人都极力否认自己的问题，或者声称自己很忙，让对方先去排查。如果对方排查出来了问题在对方那里，那么自己就省了排查和修改力气；如果对方排查发现是自己的问题，那么自己省了排查的力气，只是修改一下就行了；如果对方也不确定问题在哪，这个时候才去认真排查问题。所以，这里就是后发制人，后排查的人有更大的概率减少工作量。 推荐做法：寻找一个第三方，共同讨论这个问题可能出现的原因，然后敦促多方排查这个问题，从而提升效率。 测试提的Bug才是Bug 真实案例：前后端共同开发一个功能模块。在对接接口的时候，前端发现了有一个接口特别慢，从请求到返回需要十几秒，于是他把这个问题反馈给后端，让他看一下。但是后端一直都不处理，直到测试人员在测试的时候也发现了这个问题，提了bug之后才去修改。 心理分析：这样的人在工作的时候，只和少数人紧密联系，并且和这几个人联系的目的，是解决自己必须要做的工作。他可能心存侥幸，有小部分的概率测试人员没有发现或者不关心这个问题，这样就能减少工作量了。就算最终测试还是提了这个Bug，无非是多一个要改的Bug而已，只是修改时间的问题。 推荐做法：提交版本前自测的时候，看看对方有没有解决这个问题，如果没有解决，就把这个问题提前反馈给测试。为什么要这么做呢？主要是为了减少团队的工作量和沟通成本。 先把功能实现，优化以后再做这句话我们经常挂在嘴边，或者经常听到别人说，实际上，70%以上的人都没有真的去做优化。“先把功能实现，以后再优化”这句话仿佛是一个缓兵之计，只是解决当前的问题，并没有从长远考虑。 实际上，80%以上所谓的“未来优化计划”，最终都没有真正落实，结果就是，我们的项目背上了越来越多的技术债，到后面变得很难维护。 推荐做法：经常进行代码审查，或者把优化作为平时开发的任务之一，或者把优化作为下一期必须要做的事，这对于需要长期维护的项目来说很重要。 那个推荐你买股票基金的人，并不是真的希望你赚钱如果你身边的人经常劝你买一些股票基金，或者经常晒出自己的收益来诱惑你，这时候要有清醒的头脑，他们不是真的希望你赚钱。 从两个角度来证明： 假设买了A推荐的股票最终赚了，A就会以“高手”的身份自居，享受萌新的膜拜； 假设买了A推荐的股票最终亏了，也是正常的事，A肯定也亏了，不过A会觉得不只是自己吃亏，心里又得到一点安慰。 偶然的东西多次重复之后，就变成了必然有一种炒股诈骗方式，就是所谓的“大师”出去讲座，给100个人推荐了100个不同的股票，根据概率，有大约一半的人认为“大师”有点水平，然后“大师”再次联系这50个人，再推荐一波，又有大约25个人相信了大师。连续两次，差不多打消了疑虑，最终上当受骗。 爱情公寓5有一集冒充幼儿园园长诈骗的方式，其实原理差不多，赚的是概率的钱。 我们要保持清醒的头脑，偶然事件必然发生，都是人为操控的。我们也可以往好的方向去想：假设做一件事成功的概率是1%，我们如果重复100次，那么我们至少成功一次的概率是多少？ 1 - 0.99 ^ 100 = 63.4% 关于赌博我村有几个人沉迷于赌博，无论是线上还是线下，我在这里从多个角度来证明赌博必输。 角度1: 无论是线上还是线下，赌博本身都不是收费的，资金是从参与者流向平台或者棋牌室。举个极端的例子，四个人打麻将，一局一元，每局胡牌的人要给棋牌室一元。100局过后，求解最终四个人中至少有一个人赢钱的概率。 角度2: 假设把赌博作为随机事件，因为需要付钱给棋牌室，把这个也作为收益，输钱的概率就略大于赢钱的概率，也就是输多赢少。显然，输多赢少就是输，这个是公理，无需论证。 角度3: 风险极大。假设别人出千或者在网络上暗箱操作，输钱的概率进一步增大；假设自己出千，就要冒着被抓住的风险，侥幸心理不能有。两条路都是绝路。 赌王为什么富有，因为他不赌，他是第三方平台。","categories":[{"name":"生活感悟","slug":"生活感悟","permalink":"https://github.com/beat-the-buzzer/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"}],"tags":[{"name":"感悟","slug":"感悟","permalink":"https://github.com/beat-the-buzzer/tags/%E6%84%9F%E6%82%9F/"}]},{"title":"前端工程化——Gulp简单使用","slug":"gulp-basic","date":"2020-05-31T16:00:00.000Z","updated":"2023-12-06T15:25:19.244Z","comments":true,"path":"2020/06/01/gulp-basic/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/06/01/gulp-basic/","excerpt":"","text":"项目Git地址：https://github.com/beat-the-buzzer/gulp-test.git 前言：认真审视自己的职业如果有人问你的职业是什么，你该如何回答？ 码农、程序员、程序猿、程序媛、IT行业、计算机的、软件开发、写页面的、做网站的、前端开发、Java开发等等。 看一下自己职业的全称：前端开发工程师。 我们应该是个工程师，即使自己现在做的工作可能和“工程师”三个字相距甚远，但是对于项目的工程化，我们已经没有办法回避了。什么？你说你每天只想做好自己的工作，这些工程化的东西都交给高级开发人员或者架构师。难道你不是以高级开发为目标的吗？ Gulp初探Gulp是什么Gulp是基于流的自动化构建工具。它不仅能对资源进行优化，而且在开发过程中能够通过配置自动完成很多重复的任务，让我们可以专注于代码，提高工作效率。 Gulp是基于Nodejs的自动任务运行器， 它能自动化地完成 javascript/coffee/sass/less/html/image/css 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。 为什么要使用Gulp——为什么要使用自动化工具可以交给机器去做的事，我们都可以交给机器去做。比如，我们想给我们写好的CSS加上浏览器前缀，我们不可能手动一个一个去加，Gulp可以轻松解决这个问题。 Gulp可以解决哪些问题 编译ES6 压缩 html、css、js 优化图片…… Gulp的优缺点我们知道，Gulp是基于流的自动化构建工具，所以Gulp很适合像流水线一样处理文件，给文件新增一些处理之后再输出； Gulp不适合处理文件之间的依赖关系； 其他工具 Webpack Grunt Gulp实战操作 本项目中的gulp的版本是3.9.1 文件复制——熟悉Gulp语法1234gulp.task('copy', function() &#123; return gulp.src('src/**/*') .pipe(gulp.dest('dist'))&#125;); src() 读取文件，也就是我们即将处理哪些文件 pipe() 用于文件流的处理和转换 dest() 最终文件的输出目录 处理HTML1234567var htmlmin = require('gulp-htmlmin'); // 压缩html文件// 压缩 *.html文件，把src文件夹下面所有后缀为.html的文件进行压缩操作gulp.task('compress_html', function () &#123; return gulp.src('src/**/*.html') .pipe(htmlmin(&#123; collapseWhitespace: true &#125;)) .pipe(gulp.dest('dist'))&#125;); 处理CSS12345678910var autoprefixer = require('gulp-autoprefixer'); // 给CSS新增浏览器前缀var cssmin = require('gulp-clean-css'); // 压缩css文件// 先给*.css添加浏览器前缀，然后压缩 *.css// autoprefixer会自动读取浏览器列表gulp.task('compress_css', function () &#123; return gulp.src(['src/**/*.css']) .pipe(autoprefixer()) .pipe(cssmin()) .pipe(gulp.dest('dist'))&#125;); autoprefixer()会自动读取.browserslistrc里面的配置，从而选择性新增CSS前缀。 处理JS123456789var babel = require('gulp-babel'); // 编译es6var uglify = require('gulp-uglify'); // 压缩丑化js文件//先编译es6,再压缩js，会读取配置gulp.task('compress_js', function () &#123; return gulp.src(['src/**/*.js']) // 获取.js .pipe(babel()) // 编译es6 会自动读取.babelrc里面的配置 .pipe(uglify()) // 压缩js .pipe(gulp.dest('dist'))&#125;); babel()会自动读取.babelrc文件里面的配置。presets是ES6的编译集合。例如，我们要编译解构赋值的语法，如果不加stage-0，编译就会报错。如果我们需要更高级的语法，就需要装其他的编译插件，例如，我们如果使用装饰器语法，就需要额外的编译插件：babel-plugin-transform-decorators-legacy。 处理图片1234567var imagemin = require('gulp-tinypng-nokey'); // 压缩图片// 压缩图片gulp.task('compress_img', function () &#123; gulp.src('./src/**/*.&#123;png,jpg,jpeg,gif,ico&#125;') .pipe(imagemin()) .pipe(gulp.dest('dist'))&#125;); 整合所有任务1gulp.task('default', ['compress_html', 'compress_css', 'compress_js', 'compress_img']); 以上就是Gulp的初级用法。","categories":[{"name":"工程化","slug":"工程化","permalink":"https://github.com/beat-the-buzzer/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"工程化","slug":"工程化","permalink":"https://github.com/beat-the-buzzer/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"gulp","slug":"gulp","permalink":"https://github.com/beat-the-buzzer/tags/gulp/"}]},{"title":"面试评价表","slug":"interview-set","date":"2020-05-26T16:00:00.000Z","updated":"2023-12-06T15:25:19.245Z","comments":true,"path":"2020/05/27/interview-set/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/05/27/interview-set/","excerpt":"","text":"面试评价表——技术篇计算机行业的工作是都是非常综合的，并不是说你技术达到标准就能胜任这份工作。最简单的标准，就是你负责的模块能否正常运转和后期的维护。这里主要总结为下面7种能力： 独立思考能力 自我管理能力 解决问题能力 岗位专业能力 理解分析能力 沟通协调能力 进度管控能力 能力简介 能力详情 独立思考能力 1、善于学习、乐于创新，对新事物有自己的认知和见解 2、能坚定自己的意见，不为表象意见所左右 自我管理能力 1、能自主开展工作，自觉遵守和执行各项工作规范 2、会控制情绪，能正确面对压力和困难 解决问题能力 1、具有解决同类问题的经验和成功案例 2、能独立、准确、高效地解决出现的工作难题 岗位专业能力 1、工作成果 2、熟练掌握岗位必备的专业知识和技能 3、具有相同或类似的工作性质或过程 4、良好的专业工作习惯 理解分析能力 1、能准确理解需求或他人的目的和要求 2、对理解的地方能进行有效的分析、整理和落实 沟通协调能力 1、能说服各方接受或执行自己的观点和想法 2、能主动去沟通，推动相关事项的有效开展 进度管控能力 1、能按计划部署以及变化情况及时开展工作 2、在出现状况时，会想方设法确保进度和成果达成 面试评价表——专业经理 能力简介 能力详情 独立思考能力 1、最近都学了哪些新的东西？为什么学这些？ 2、你的职业规划和后续发展是怎么样的？为什么要这样规划？ 3、最近有关注什么新闻和事件吗？谈谈你的看法。 自我管理能力 1、平常的作息时间是怎样的？（具体怎么安排的） 2、业余时间都在做什么？（习惯、规律和兴趣） 3、任务少或者主管没有要求的时候，自己怎么开展工作的？ 4、任务紧压力大的时候，你是怎么调节自己的？ 5、遇到很生气的事情，通常是怎么做的？ 解决问题能力 1、在之前的工作中，有没有遇到难题，你是怎么解决的？ 2、面对一项从未触及过的任务，你通常是如何完成它的？ 3、谈你工作中最有成就感的一两件事，有什么收获？ 岗位专业能力 1、你之前主要是做哪方面？你主要负责哪部分？你最擅长的是什么？ 2、你上一份工作最大的成果是什么？哪些地方让你最有成就感？ 3、请画出你做的部分的框架图（结构）以及工作流程图并做说明。 4、你们开展工作都必须要遵守哪些工作规范？请举例说明。 理解分析能力 1、有没有接触过跟我们类似的产品？谈谈你对这类产品的理解。 2、从你岗位的角度谈谈，怎样才能做好这个产品。 沟通协调能力 1、有没有根跟其他人意见有分歧的情况？你是怎么处理的？最后的结果如何？ 2、你工作中是否有过被拒绝或者不配合的情况？你是如何处理的。 进度管控能力 1、你每个月工作实际的进展和计划有没有出入？为什么。 2、有没有准时按计划完成的大任务？举例说明下具体计划和实施过程。 3、有没有延期的情况？你是怎么处理的。","categories":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"VSCode装机必备的插件","slug":"vscode-plugins-v1","date":"2020-03-13T16:00:00.000Z","updated":"2023-12-06T15:25:19.248Z","comments":true,"path":"2020/03/14/vscode-plugins-v1/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/03/14/vscode-plugins-v1/","excerpt":"","text":"先换主题——SynthWave ‘84安装了VSCode，第一步是干什么。大部分人都会选择去汉化，但是我的第一步，是换主题。 之前在网上看到这个主题： SynthWave &#39;84，就用了一下，从此一直没换过。 路径自动补全——Path Intellisense这是一个非常实用的插件，我们经常引用文件路径时，如果没有自动补全，我们就需要一层一层去寻找，这样不仅效率低，而且容易出错。使用这个插件，可以在输入斜线的时候，自动匹配到对应的目录。 代码运行——Code Runner这个插件也是我非常喜欢的。有时候我们为了测试自己的代码，经常会把代码复制到浏览器上去运行，或者直接在浏览器的控制台上去写一些代码，这样很麻烦。有了这个插件，我们可以在项目中新建一个测试用的JS文件，然后直接在VSCode上面运行。 在浏览器中打开——open in browser上面我们讲到了Code Runner这个插件，在这里运行的代码，只能是JS的方法，不能进行DOM操作。我们也经常写一些测试用的HTML文件，但是我们发现，我们无法直接在VSCode中打开HTML文件，只能找到对应点文件，手动打开。为此，我们可以使用这个插件，只需要右键，就能在指定浏览器中打开HTML文件。 预览Markdown——Markdown Preview Enhanced我们经常要写一些Markdown的说明文档。我们知道，使用特定的标识，就会有特定的展示效果。我们需要在编辑的时候预览，所以就用到了这个插件。这个插件运行方式，就是在Markdown文件上右键，支持源文件和效果同时展示。 代码校验——ESLint我们知道，一般在Vue或者React的脚手架里面，都会内置Webpack，有时候也会自带ESLint。但是，脚手架里面的ESLint有一个不好的地方，就是只要你有不符合规范的地方，比如多一个空格，编译都直接报错。所以，ESLint这个插件解决了这个问题。我们使用这个插件，会在VScode底部看到报错信息，并且项目也能正常运行。 HTML标签自动修改——Auto Rename Tag顾名思义，自动完成另一侧标签的同步修改。几个字就能概括出这个插件的实用性。 CSS兼容利器——Autoprefixer如果我们的项目已经用webpack之类的工具配好了Autoprefixer，我们就可以放弃这个插件。如果我们的项目没有关于CSS兼容的配置，Autoprefixer这个插件是一个极好的选择。这个插件的用法很简单，保存的时候，对那些需要加前缀的样式，就会自动生成了。 格式化利器——Beautify其实有很多种格式化代码的插件，但是我选择了Beautify，主要是因为这个插件的格式化标准，和ESLint的检查方式是一样的。 区块的区分——Bracker Pair Colorizer我在很久之前用过一个代码编辑器，叫HBuilder，这个编辑器只要双击花括号，就能选中花括号范围内的代码。其实多数情况下，我们不需要选中，我们需要清楚地看到花括号里面有哪些代码，尤其是代码逻辑复杂，很长的时候。Bracker Pair Colorizer这个插件就能很好地解决这个问题。 To Be Continued!","categories":[{"name":"其他","slug":"其他","permalink":"https://github.com/beat-the-buzzer/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://github.com/beat-the-buzzer/tags/VSCode/"}]},{"title":"数组去重的N个方法","slug":"unique","date":"2020-01-10T16:00:00.000Z","updated":"2023-12-06T15:25:19.248Z","comments":true,"path":"2020/01/11/unique/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/01/11/unique/","excerpt":"","text":"数组去重是一个出现频率极高的面试题，这个问题很经典，有很多种解决办法。如果真的被问到了这个题或者笔试题有这道题，如果你简简单单写一个new Set()，并不会给你带来加分的效果。面试的时候，要去清楚地描述解决问题的思路和过程，而不仅仅是解决这个问题。 ES6 Set数据结构ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 这里的重复判断是在===的基础上新增了对NaN的判断。 12345function unique (arr) &#123; return [...new Set(arr)];&#125;var arr = [true, true, undefined, undefined, null, null, NaN, NaN, 0, 0, 'a', 'a', &#123;&#125;, &#123;&#125;];console.log(unique(arr)); 对于对象类型的，arr最后两项是两个不同的字面量，不是重复的数据，如果我用下面的写法，就是另外的结果了： 1234var obj = &#123; a: 1 &#125;;arr.push(obj);arr.push(obj);console.log(unique(arr)); // 此时数组中只有一个 &#123;a: 1&#125; 循环遍历法双重循环是一个大思路，具体的实现形式有很多种，这里只去举一个例子： 12345678910111213function unique (arr) &#123; var temp = []; for(var i = 0; i &lt; arr.length; i++) &#123; // 判断arr中的元素在temp中是否嫩找到，如果能找到，就不做操作，找不到的话，就把这个元素push到temp中 if (temp.indexOf(arr[i]) === -1) &#123; // 不存在的元素 temp.push(arr[i]) &#125; &#125; return temp;&#125;var arr = [true, true, undefined, undefined, null, null, NaN, NaN, 0, 0, 'a', 'a', &#123;&#125;, &#123;&#125;];console.log(unique(arr)); 这里其实可以看做是双重循环，indexOf也算是一种循环。这里的问题就在于对NaN的判断，NaN并不等于自身，所以会返回两种NaN。 利用对象的key我们都知道，对象的Key是唯一的，利用这个特性我们可以有一个去重的思路。不过对象的key还有一个特点，就是key值必然是字符串。 12345678910111213function unique(arr) &#123; var temp= []; var obj = &#123;&#125;; // 用于存储键值 for (var i = 0; i &lt; arr.length; i++) &#123; if (!obj[arr[i]]) &#123; temp.push(arr[i]); // 不存在的key，存起来 obj[arr[i]] = 1; &#125; else &#123; obj[arr[i]]++; // 记录有重复的个数 &#125; &#125; return temp;&#125; 不过上面这种方式有很大的局限性，字符串’1’和数字1、true和’true’也被认为是重复的。 简单改进一下，加上类型判断，使用hasOwnProperty方法： 123456789101112131415161718function unique(arr) &#123; var obj = &#123;&#125;; return arr.filter(function(item, index) &#123; return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) &#125;)&#125;// 这两个函数是同样的功能，上面的写法更加简洁，下面的写法更加易懂function unique(arr) &#123; var obj = &#123;&#125;; return arr.filter(function(item, index) &#123; if(obj.hasOwnProperty(typeof item + item)) &#123; return false; &#125; else &#123; obj[typeof item + item] = true; return true; &#125; &#125;)&#125; 这里把数组的值和数组的typeof值进行拼接，用计算后的值作为key，如果obj里面存了key，就return false过滤掉，没存的话，就选中了这个值，并且更新了obj对象。 这种方式的缺陷在于对对象的判断，如果数组中的元素分别是{a: 1}和{b: 2}两个对象，这两个对象计算出来的key都是object[object Object]，最后会被filter过滤掉。 在JavaScript中，如果非字符串类型的数据作为对象的key，这个值会被转成字符串类型。那么，有没有一个方法，把非字符串类型的数据作为key呢？ ES6提供了一种新的数据结构——Map，它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 12345678910111213function unique(arr) &#123; var map = new Map(); var array = new Array(); // 数组用于返回结果 for (var i = 0; i &lt; arr.length; i++) &#123; if(map.has(arr[i])) &#123; // 如果有该key值 map.set(arr[i], true); // 把arr[i]作为map的key, true作为value &#125; else &#123; map.set(arr[i], false); // 如果没有该key值，就把这个key放到数组中 array.push(arr[i]); &#125; &#125; return array ;&#125; 用Map的方式可以解决key值去重带来的问题。 其他方法123456function unique(arr) &#123; return arr.filter(function(item, index) &#123; //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素 return arr.indexOf(item, 0) === index; &#125;);&#125; 这里的局限性还是在于indexOf方法，先在MDN文档里面找到Array#indexOf的polyfill: 123456789101112131415161718192021222324// This version tries to optimize by only checking for \"in\" when looking for undefined and// skipping the definitely fruitless NaN search. Other parts are merely cosmetic conciseness.// Whether it is actually faster remains to be seen.if (!Array.prototype.indexOf) Array.prototype.indexOf = (function(Object, max, min) &#123; \"use strict\" return function indexOf(member, fromIndex) &#123; if (this === null || this === undefined) throw TypeError(\"Array.prototype.indexOf called on null or undefined\") var that = Object(this), Len = that.length &gt;&gt;&gt; 0, i = min(fromIndex | 0, Len) if (i &lt; 0) i = max(0, Len + i) else if (i &gt;= Len) return -1 if (member === void 0) &#123; // undefined for (; i !== Len; ++i) if (that[i] === void 0 &amp;&amp; i in that) return i &#125; else if (member !== member) &#123; // NaN return -1 // Since NaN !== NaN, it will never be found. Fast-path it. &#125; else // all else for (; i !== Len; ++i) if (that[i] === member) return i return -1 // if the value was not found, then return -1 &#125; &#125;)(Object, Math.max, Math.min) 因为NaN和NaN本身不相等，所以数组中的NaN，用indexOf方法是找不到的。 小结数组去重的大致方案小结： 1、双重循环，在临时数组里push新的元素； 2、利用对象、Map的key的唯一性； 3、ES6方法； 4、寻找元素首次出现的位置是否和当前位置的元素相等； …… 其中解题的核心关键在于如何去判断重复的元素，indexOf、===、typeof item + item，等等方法都有各自的优势和缺陷。 对于数组去重这样的经典的面试题，我们不仅仅要去解决问题，更应该去了解解决问题的思路，面试的意图更多的还是解题思路。另外，我们在探究的过程中，能把学过的知识串联起来，形成体系。","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://github.com/beat-the-buzzer/tags/%E7%AE%97%E6%B3%95/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"科学上网工具——shadowsocks","slug":"shadowsocks","date":"2020-01-01T16:00:00.000Z","updated":"2023-12-06T15:25:19.248Z","comments":true,"path":"2020/01/02/shadowsocks/","link":"","permalink":"https://github.com/beat-the-buzzer/2020/01/02/shadowsocks/","excerpt":"","text":"使用翻墙的场合我们在平时工作的时候，难免会需要科学上网，例如： Google应用商店的一些工具或者插件 一些国外的视频（图为babel官网） 移动端真机调试 下面就使用shadowsocks工具以及网上可以查到的SS节点进行免费翻墙。 shadowsocks工具下载和使用百度搜索关键字“free ss”： 搜索页面 在ishadow里面下载shadowsocks工具，根据自己的系统下载对应的安装包。https://get.ishadowx.biz/ 在这个网站上，我们还能获取到节点的信息，点击图中的位置，可以在屏幕上生成一个二维码。 点击查看二维码 打开shadowsocks，右键右下角的图标（Mac的图标在屏幕最上方），选择服务器 =&gt; 扫描屏幕上的二维码 识别二维码 测试是否成功：https://www.google.com.hk/webhp?hl=zh-CN&amp;sourceid=cnhp&amp;gws_rd=ssl可能遇到的问题二维码无法扫描或者扫描成功之后无法翻墙不是所有的二维码都能成功，要多次尝试。 500 Internal Privoxy Error 报错页面 我是换了工位之后出现了这个错误，网上搜了一下，需要重置网络。 123netsh interface ipv4 resetnetsh interface ipv6 resetnetsh winsock reset","categories":[{"name":"其他","slug":"其他","permalink":"https://github.com/beat-the-buzzer/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://github.com/beat-the-buzzer/tags/Shadowsocks/"}]},{"title":"算法系列——贪心算法","slug":"greedy","date":"2019-12-14T16:00:00.000Z","updated":"2023-12-06T15:25:19.244Z","comments":true,"path":"2019/12/15/greedy/","link":"","permalink":"https://github.com/beat-the-buzzer/2019/12/15/greedy/","excerpt":"","text":"项目Git地址：https://github.com/beat-the-buzzer/algorithm-for-javascript/tree/master/greedy 贪心算法简介一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。 使用贪心算法的条件： 贪心选择性质：原问题的整体最优解可以通过一系列局部最优的选择得到 最优子结构：一个问题的最优解包含其子问题的最优解 冒泡排序、选择排序，是否用到了贪心算法？ 拿冒泡排序为例，每一次遍历，找到的最大的元素，下一次遍历，是在剩余的部分再去寻找最大的元素。贪心策略就是每一次从剩下的序列中选一个最大的数，把这些最大的数放在一起，就是排序后的结果。 贪心算法demo最优装载问题海盗船载重量为C，每件财宝的重量为wi，如何装载最多数量的财宝？ 显然，这里我们贪心的东西是数量，所以贪心策略就是从小的开始装，这样会得到最大的数量。 1234567891011121314151617181920212223242526272829var w = [4, 10, 7, 11, 3, 5, 14, 2]; w.sort(function (a, b) &#123; return a - b &#125;); // 首先对重量进行排序var carry = 30; // 船的载重量var temp = 0; // 已经在船上的重量var ans = 0; // 已经在船上的数量for (var i = 0; i &lt; w.length; i++) &#123; temp += w[i]; // 把财宝放到船上 if (temp &lt;= carry) &#123; ans++; // 没超重-&gt; 计数 &#125; else &#123; break; // 超重 -&gt; 直接退出循环 &#125;&#125;console.log('最后带走的财宝数量：' + ans);var temp1 = 0;var ans1 = 0;for (var j = 0; j &lt; w.length; j++) &#123; temp1 += w[j]; if (temp1 &gt;= carry) &#123; if (temp1 == carry) &#123; ans1 = j + 1; // 正好装潢 -&gt; 最后一个可以放 &#125; else &#123; ans1 = j; // 已经超出，最后一个不能放 &#125; &#125;&#125;console.log('最后带走的财宝数量：' + ans1); 背包问题n种宝物，每种宝物都有对应的重量w和对应的价值v，一次只能运走m重量的宝物，一种宝物只能拿一样，宝物可以分割。如何带走最大价值的宝物？ 这种情况下的贪心策略就是去装单位重量内最值钱的。 123456789101112131415161718192021222324252627282930313233343536class Treasure &#123; constructor(w, v) &#123; // 传入重量和价值 this.w = w; this.v = v; this.p = v / w; &#125;&#125;var wArr = [4, 2, 9, 5, 5, 8, 5, 4, 5, 5];var vArr = [3, 8, 18, 6, 8, 20, 5, 6, 7, 15];var len = wArr.length;var treasureArr = [];for (var i = 0; i &lt; len; i++) &#123; treasureArr[i] = new Treasure(wArr[i], vArr[i]);&#125;// 得到对象数组treasureArr.sort(function (a, b) &#123; return b.p - a.p &#125;); // 按照单位重量的价值进行排序（从大到小）var m = 30; // 总的承重var sum = 0; // 运走的总价值for (var j = 0; j &lt; len; j++) &#123; if (m &gt; treasureArr[j].w) &#123; // 如果可以把第j个物品装满，就去装 m -= treasureArr[j].w; sum += treasureArr[j].v; &#125; else &#123; // 如果第j个物品装不满，就把剩余的重量用这个物品装满 sum += m * treasureArr[j].p; break; &#125;&#125;console.log('带走财宝的总价值：' + sum); 如果物品不可分割，那么这个问题就不能使用贪心策略，举个例子： 物品列表中，有一个100斤的黄金和100克的废铁。承重量是30斤。那么一开始选择黄金，装不下，由于不可分割，算法结束，啥也没装，不可能是最优解。 不可分割的问题叫做： 0-1背包问题。关于这个问题后续会给出其他算法。 哈夫曼树在初学编程的时候，我们都做过这样的题：将考试分数转化成等级，90分以上的为A，8090的为B，7080的为C，60~70的为D，60以下的为不及格。我们会写出这样的代码： 1234567891011if(score &gt;= 90) &#123; return '优秀';&#125; else if(score &gt;=80) &#123; return '良好';&#125; else if(score &gt;=70) &#123; return '中等';&#125; else if(score &gt;= 60) &#123; return '及格';&#125; else &#123; return '不及格！！！';&#125; 显然这样的代码没有任何问题，但是我们考虑的点不在这里。我们要考虑，学生的分数呈正态分布，我们应该把频率最高的放在第一个，这样比较多的数据只需要比较一次，从而减少总的比较次数，提升效率。 如果这个例子不够清晰，我们再举出其他的例子：如果我们要去猜一个老教授的年龄，我们先猜老教授是否是1岁，如果不是，再猜老教授是否是2岁，以此类推。其实，这个问题和上面分数的问题是同一类问题。我们优化一下上面的分数问题。 假设优秀、良好、中等、及格、不及格这五种情况的频率分别是0.1、0.2、0.4、0.2、0.1。我们可以这样改写程序： 123456789101112131415if (score &lt; 80) &#123; if (score &lt; 70) &#123; if (score &lt; 60) &#123; return '不及格'; &#125; else &#123; return '及格'; &#125; &#125; else &#123; return '中等'; &#125;&#125; else if (score &lt; 90) &#123; return '良好';&#125; else &#123; return '优秀';&#125; 根据上面的频率，假设现在有100个学生，那么第一种情况的比较次数大约为： 1100*0.1*1 + 100*0.2*2 + 100*0.4*3 + 100*0.2*4 + 100*0.1*5 &#x3D; 300(次) 第二种情况的比较次数大约为： 1100*0.1*3 + 100*0.2*3 + 100*0.4*2 + 100*0.2*2 + 100*0.1*2 &#x3D; 230(次) 两种方法的差别还是不可忽视的。其实我们可以总结规律：把频率大的部分靠近树根，一次成功的概率会大大提升。 哈夫曼编码的思想其实和这个一样，用字符的使用频率作为权构建一颗哈夫曼树。构建方法是自底向上，进行合并。核心思想是权值越大的元素离根越近。 贪心策略：每次从树的集合中取出没有双亲且权值最小的两棵树左右子树，构造出一棵新树。 下面来看一下哈弗曼树的构建步骤： 以（7,18,3,32,5,26,12,8） 为例： 1、初始状态 2、找到权值最小的两个节点，进行合并，如下图，我们把3和5合并成8 3、对剩余节点和新合成的节点，再次寻找权值最小的两个节点，进行合并，7和8可以合成15，这里两个8，随机选择，不影响结果。 4、下一步操作，选择8和12，合并成20 5、下一步操作，15和18，合成33 6、下一步操作，20和26，合并成46 7、下一步操作，33和32，合并成65 8、下一步操作，65和46，合并成111，此时只剩一个节点，这个节点作为根节点，算法结束 看一下根节点的位置： 如图，我们看到，距离根越近的节点，权值越大。","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/beat-the-buzzer/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://github.com/beat-the-buzzer/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法系列——分治法","slug":"divive","date":"2019-12-03T16:00:00.000Z","updated":"2023-12-06T15:25:19.243Z","comments":true,"path":"2019/12/04/divive/","link":"","permalink":"https://github.com/beat-the-buzzer/2019/12/04/divive/","excerpt":"","text":"项目Git地址：https://github.com/beat-the-buzzer/algorithm-for-javascript/tree/master/divide-and-conquer 分治法简介先分，再解决，最后合。 再探归并排序归并排序合快速排序也是分治法的一种应用。传送门：https://beat-the-buzzer.github.io/2019/12/03/sort/#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F 这里重新讲解一下归并排序： 归并排序，首先我们写一个方法，把两个有序的数组合并成一个有序的数组。 我们把原数组对半分割，生成的子数组如果可以分割，就继续分割。到最后，每个子数组只有一个元素。 很显然，只有一个元素的数组必然是有序的，所以我们把最后分割得到的数组进行合并操作，最终合并完全之后，得到了有序的数组。 我们对于分治法，最简单的应用就是查找，二分查找，也叫折半查找。就是在一个有序的数组中寻找某个元素，我们按照常理来，就是遍历数组，其实，如果数组本身是有序的，我们就可以使用效率更高的二分查找。就是拿数组中间的数和要找的数进行比较，这样可以缩小查找的范围，直到找到或者找不到为止。下面是详细代码 1234567891011121314151617181920// 二分查找的实现function binaryQuery (arr, x) &#123; var low = 0; var high = arr.length - 1; while (low &lt;= high) &#123; var middle = parseInt((low + high) / 2); if (x === arr[middle]) &#123; return middle; // 查到了，返回索引值 &#125; else if (x &lt; arr[middle]) &#123; high = middle - 1; // 如果要查的值比中点小，就去前半部分查 &#125; else &#123; low = middle + 1; // 如果要查的数比中点大，就去后半部分查 &#125; &#125; return -1; // 查不到，返回-1，类似indexOf方法&#125;var arrTest = [1, 2, 4, 6, 8, 9, 11, 15, 22, 32, 44, 56, 62, 77, 86, 99, 100];console.log(binaryQuery(arrTest, 32));console.log(binaryQuery(arrTest, 10)); 显然，对于这样的问题，我们还可以使用递归的方式进行，问题很简单，直接看代码，绝对能看懂。 12345678910111213141516171819// 二分查找的递归实现function binaryQueryRe (arr, x, low, high) &#123; if (low &gt; high) &#123; return -1; &#125; var mid = parseInt((low + high) / 2); if (x === arr[mid]) &#123; return mid; &#125; else if (x &gt; arr[mid]) &#123; return binaryQueryRe(arr, x, mid + 1, high); &#125; else &#123; return binaryQueryRe(arr, x, low, mid - 1); &#125;&#125;var arrTestRe = [1, 2, 4, 6, 8, 9, 11, 15, 22, 32, 44, 56, 62, 77, 86, 99, 100];console.log(binaryQueryRe(arrTestRe, 32, 0, arrTestRe.length - 1)); // 9console.log(binaryQueryRe(arrTestRe, 10, 0, arrTestRe.length - 1)); // -1 二分查找非递归实现12345678910111213141516171819202122// 二分查找的实现function binaryQuery(arr, x) &#123; var low = 0; var high = arr.length - 1; while (low &lt;= high) &#123; var middle = parseInt((low + high) / 2); if (x === arr[middle]) &#123; return middle; // 查到了，返回索引值 &#125; else if (x &lt; arr[middle]) &#123; high = middle - 1; // 如果要查的值比中点小，就去前半部分查 &#125; else &#123; low = middle + 1; // 如果要查的数比中点大，就去后半部分查 &#125; &#125; return -1; // 差不到，返回-1，类似indexOf方法&#125;var arrTest = [1, 2, 4, 6, 8, 9, 11, 15, 22, 32, 44, 56, 62, 77, 86, 99, 100];console.log(binaryQuery(arrTest, 32)); // 9console.log(binaryQuery(arrTest, 10)); // -1 递归实现12345678910111213141516171819// 二分查找的递归实现function binaryQueryRe(arr, x, low, high) &#123; if (low &gt; high) &#123; return -1; &#125; var mid = parseInt((low + high) / 2); if (x === arr[mid]) &#123; return mid; &#125; else if (x &gt; arr[mid]) &#123; return binaryQueryRe(arr, x, mid + 1, high); &#125; else &#123; return binaryQueryRe(arr, x, low, mid - 1); &#125;&#125;var arrTestRe = [1, 2, 4, 6, 8, 9, 11, 15, 22, 32, 44, 56, 62, 77, 86, 99, 100];console.log(binaryQueryRe(arrTestRe, 32, 0, arrTestRe.length - 1)); // 9console.log(binaryQueryRe(arrTestRe, 10, 0, arrTestRe.length - 1)); // -1","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/beat-the-buzzer/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://github.com/beat-the-buzzer/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"算法系列——排序算法","slug":"sort","date":"2019-12-02T16:00:00.000Z","updated":"2023-12-06T15:25:19.248Z","comments":true,"path":"2019/12/03/sort/","link":"","permalink":"https://github.com/beat-the-buzzer/2019/12/03/sort/","excerpt":"","text":"Git地址：https://github.com/beat-the-buzzer/algorithm-for-javascript/tree/master/sort 选择排序 遍历数组，每次遍历，把较小数的索引存起来。第一次遍历，找到了最小的数，和数组的第一个元素进行交换，第二次遍历，从第二个开始，找到了剩余最小的数，和数组的第二个元素进行交换。以此类推。 下面展示我的代码和注释： 123456789101112131415161718192021// 选择排序算法实现function selectSort(arr) &#123; const arrCopy = [...arr]; // 复制一份数组 const len = arrCopy.length; let tempIndex; // 保存最小的数的索引 for (let i = 0; i &lt; len - 1; i++) &#123; tempIndex = i; // j是从i+1开始，因为每次趟下来最小的已经确定了， for (let j = i + 1; j &lt; len; j++) &#123; if (arrCopy[tempIndex] &gt; arrCopy[j]) &#123; tempIndex = j; &#125; &#125; // 一趟for循环，找到了最小的元素的索引，并且把它存在tempIndex中，下面就是交换这个最小的元素和第i个元素 [arrCopy[tempIndex], arrCopy[i]] = [arrCopy[i], arrCopy[tempIndex]]; &#125; return arrCopy;&#125;const arr = [3, 1, 4, 5, 2, 7, 9, 6, 8];selectSort(arr); 这里有一些操作，我会在这里慢慢展示。 交换的实现我们平常想到交换两个数的方式就是弄一个临时变量，其实可以一行搞定。这里使用了ES6的数组解构赋值。 123let a = 1;let b = 2;[a, b] = [b, a]; 冒泡排序 遍历数组，比较相邻的两个数，如果前面的较大，就交换，这样一趟下来，最大的数必然在最后一个。最大的数慢慢沉下去，我称之为“石头算法”。 12345678910111213141516// 冒泡排序算法实现function bubbleSort(arr) &#123; const arrCopy = [...arr]; const len = arrCopy.length; for (let i = 0; i &lt; len - 1; i++) &#123; // 每次for循环，最大的元素都会沉底，所以内层的j每次都会减少 for (let j = 0; j &lt; len - 1 - i; j++) &#123; if (arrCopy[j] &gt; arrCopy[j + 1]) &#123; [arrCopy[j], arrCopy[j + 1]] = [arrCopy[j + 1], arrCopy[j]]; &#125; &#125; &#125; return arrCopy;&#125;const arr = [3, 1, 4, 5, 2, 7, 9, 6, 8];console.log(bubbleSort(arr)); // arr已经排完序 为什么要在一开始复制一份数组？我在同一个JS文件里面写了两个排序算法，在没有复制数组，调用的时候，我是这样操作的： 12345function selectSort () &#123;...&#125; // 没有复制数组function bubbleSort () &#123;...&#125; // 没有复制数组const arr = [3, 1, 4, 5, 2, 7, 9, 6, 8];console.log(selectSort(arr));console.log(bubbleSort(arr)); // arr已经排完序 如果我们不去复制一份数组，每次调用排序算法之后，原数组也被改变了。第二次调用的时候，传入的数组本来就是有序的。这是浅拷贝的问题，造成外部变量无意之间发生了改变。 归并排序归并排序的思想就是分治法，先分再合。先说“合”：我们需要写一个函数，这个函数可以把两个有序的数组合并成一个有序的数组。合并的方法是，给两个数组准备两个指针，并且准备一个空数组用于存储合并后的值。比较两个指针对应位置的值，较小的值存入准备的空数组中，然后较小的值对应的指针向后移动。简单举个例子： 123456var A = [1, 3, 5];var B = [2, 4];// 比较1和2，发现1较小，把1存在数组中：[1]// A的指针向后移动，比较3和2，把2存在数组中：[1,2]// B的指针向后移动；比较3和4，把3存在数组中：[1,2,3]// ... 有了这个方法，我们接下来就是去“分”。很显然，如果数组中只有一个元素，那么它肯定是有序的。所以我们每次把数组一分为二，直到不能分的时候，我们再去执行合并的操作，这样到最后，就是有序的数组了。 在代码里，我没有真正意义上去分割数组，数组永远还是这个数组，我使用了变量去分割，也就是说，我的合并函数，是把前半部分和后半部分都是有序的，这样的数组“合并”成一个有序的数组，举个例子： 1var arr = [1, 3, 5, 7, 2, 4, 6, 8]; 这个数组的前半部分是1、3、5、7，后半部分是2、4、6、8，都是有序的，我把这个数组“合并”成[1,2,3,4,5,6,7,8]，下面看看代码： 1234567891011121314151617181920212223function merge(arr, low, high) &#123; const arrCopy = [...arr]; // 复制一份原始数组，因为我们要对传入的数组本身进行操作。 let i = low; // 上半部分的起始位置 let mid = parseInt((low + high) / 2); // 上半部分的结束位置 let j = mid + 1; // 下半部分的起始位置 // high是下半部分的结束位置 let k = low; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (arrCopy[i] &lt; arrCopy[j]) &#123; arr[k++] = arrCopy[i++]; &#125; else &#123; arr[k++] = arrCopy[j++]; &#125; &#125; // 可能后半部分遍历完了，前半部分还有剩余 while (i &lt;= mid) &#123; arr[k++] = arrCopy[i++]; &#125; // 可能前半部分遍历完了，后半部分还有剩余 while (j &lt;= high) &#123; arr[k++] = arrCopy[j++]; &#125;&#125; low是数组的初始位置，high是数组的末位置。事实上，上面这个方法可以对数组的连续子集进行部分操作。 “分”的方法就是递归了，能分就分，不能分就开始合，其实就是看初始位置和末位置，如果初始位置小于末位置，说明至少有两个元素，还能继续分，否则，就去执行合并操作。 123456789101112function mergeSort(arr, low, high) &#123; if (low &lt; high) &#123; const mid = parseInt((low + high) / 2); mergeSort(arr, 0, mid); mergeSort(arr, mid + 1, high); merge(arr, low, high); &#125;&#125;const arr = [3, 1, 4, 5, 2, 7, 9, 6, 8];mergeSort(arr);console.log(arr); 浅拷贝，也可以去利用我在这里归并排序的写法就是直接对数组进行操作，所以我们可以直接对传入的参数进行操作，由于浅拷贝，这样做的结果就是改变了原数组。 快速排序快速排序的思想其实很简单，就是把在数组中找一个“基准”，然后通过交换元素，把所有比基准小的元素放在基准左边，把所有比基准大的元素放在基准右边，然后对左右两部分分别做上面的操作，这样到最后，数组就有序了。我们就拿数组第一个元素作为基准，看看排序的过程是什么样子的。 1234567891011121314151617181920212223242526272829303132333435363738function partition (arr, low, high) &#123; var i = low; var j = high; var pivot = arr[low]; // 基准值 while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt; pivot) &#123; j--; // 如果后面的元素比基准大，指针就往左走，这样就找到了右边比基准小的元素的索引 &#125; if (i &lt; j) &#123; [arr[i], arr[j]] = [arr[j], arr[i]]; // 找到了右边比基准小的元素的索引，此时需要交换，然后左边指针加一 i++; // 这样最左边的元素必然是比基准小的元素 &#125; while (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123; i++; // 如果前面的元素比基准小，指针就往右走，这样就找到了左边比基准大的元素的索引 &#125; if (i &lt; j) &#123; [arr[i], arr[j]] = [arr[j], arr[i]]; // 找到了左边比基准大的元素的索引，此时需要交换，然后右边指针减一 j--; // 这样最右边的元素必然是比基准大的元素 &#125; &#125; return i; // 最终得到基准值所在位置，并且此时基准左边都比基准小，右边都比基准大&#125;var arrQuickTest = [5, 1, 7, 3, 9, 2, 8, 4, 6];partition(arrQuickTest, 0, arrQuickTest.length - 1); // 返回结果是4，也就是说，前四个都是比第五个小的，arrQuickTest变成[4, 1, 2, 3, 5, 9, 8, 7, 6]// 接下来就是递归了，我们需要对前四和后四这两部分再次划分，当不能再划分的时候，说明已经拍好了function quickSort1 (arr, low, high) &#123; var mid = partition(arr, low, high); // 得到一次排序之后基准的位置 if (low &lt; high) &#123; quickSort1(arr, low, mid - 1); // 比基准小的部分进行快速排序操作 quickSort1(arr, mid + 1, high); // 比基准大的部分进行快速排序操作 // mid的位置是正确的，不需要再次排序了 &#125;&#125;quickSort1(arrQuickTest, 0, arrQuickTest.length - 1);console.log(arrQuickTest); 其实重点在于前面的划分函数。我们来慢动作回放： 12345[5, 1, 7, 3, 9, 2, 8, 4, 6] // 初始值[4, 1, 7, 3, 9, 2, 8, 5, 6] // 右边向左边走，找到了4，比基准值小，交换，左边指针向右走一步，右边指针指向基准值5[4, 1, 5, 3, 9, 2, 8, 7, 6] // 左边向右走，找到了7.比基准值大，交换，右边指针向左一步，左边指针指向基准值5[4, 1, 2, 3, 9, 5, 8, 7, 6] // 同理，5和2交换[4, 1, 2, 3, 5, 9, 8, 7, 6] // 同理，9和5交换，一趟结束 慢动作最终结果和上面的注释是一样的。然后我们递归地对基准左边和基准右边进行同样的操作，最终得到了有序的数组。 优化快速排序在上面的快速排序里，我们每次都是和基准值进行交换，其实这个没有必要。我们的目的是把数组分成以基准值为边界的两个字序列，左边的都比基准值小，右边的都比基准值大。我们可以双向扫描，找到左边的那个比基准值大的元素，找到右边那个比基准值小的元素，这两个进行交换，这样做，比起上面的方法，交换次数少了很多。 我们继续表演慢动作： 1234[5, 1, 7, 3, 9, 2, 8, 4, 6] // 初始值[5, 1, 4, 3, 9, 2, 8, 7, 6] // 右边的指针找到了4，左边的指针找到了7，二者交换[5, 1, 4, 3, 2, 9, 8, 7, 6] // 继续，右边的指针找到了2，左边的指针找到了9，交换[2, 1, 4, 3, 5, 9, 8, 7, 6] // 右边指针向左走，走到2的位置，此时指针相遇，交换这个相遇的点和基准值，这样一趟排序结束 下面是完整代码：貌似书上的代码会导致数组溢出，我在这里进行了处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344function partition2(arr, low, high) &#123; var i = low; var j = high; var pivot = arr[low]; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; arr[j] &gt; pivot) &#123; j--; &#125; while (i &lt; j &amp;&amp; arr[i] &lt;= pivot) &#123; i++; &#125; // 得到右边比基准值小的值的索引和左边比基准值大的值的索引 if (i &lt; j) &#123; [arr[i], arr[j]] = [arr[j], arr[i]]; i++; j--; &#125; &#125; // 经过上面的循环，和j应该相遇了，此时我们要看看下标为i的元素是否比基准大 if (i &lt;= high) &#123; // 书中的代码貌似会溢出，所以当i超出数组范围的时候，不作处理 if (arr[i] &gt; pivot) &#123; // 此时交换基准和i-1对应的元素 [arr[low], arr[i - 1]] = [arr[i - 1], arr[low]]; return i - 1; // 返回基准位置 &#125; else &#123; [arr[low], arr[i]] = [arr[i], arr[low]]; return i; &#125; &#125;&#125;function quickSort2(arr, low, high) &#123; var mid = partition2(arr, low, high); // 得到一次排序之后基准的位置 if (low &lt; high) &#123; quickSort2(arr, low, mid - 1); // 比基准小的部分进行快速排序操作 quickSort2(arr, mid + 1, high); // 比基准大的部分进行快速排序操作 // mid的位置是正确的，不需要再次排序了 &#125;&#125;var arrQuickTest2 = [5, 1, 7, 3, 9, 2, 8, 4, 6];quickSort2(arrQuickTest2, 0, arrQuickTest2.length - 1);console.log(arrQuickTest2); 快速排序是不稳定的排序，它的效率和基准值有关，如果正好是倒序的数组，就是最差的情况。 插入排序12345678910111213141516// 插入排序function insertSort(arr) &#123; var arrCopy = [...arr]; for (var i = 1; i &lt; arrCopy.length; i++) &#123; var temp = arr[i]; // 记住这个元素，因为一会这个位置会被替换 var j = i - 1; while (j &gt;= 0 &amp;&amp; arrCopy[j] &gt; temp) &#123; arrCopy[j + 1] = arrCopy[j]; j--; &#125; arrCopy[j + 1] = temp; &#125; return arrCopy;&#125;var insertSortArr = [4, 2, 1, 5, 3];console.log(insertSort(insertSortArr)); 其实插入排序的原理十分通俗易懂，我称之为“麻将排序”。排序的过程就和麻将一样，举个最简单的例子： 12一万 三万 二万把三万往右拉一个位置，再把二万放在三万之前的位置 整理麻将的过程就是插入排序，下面我将一步一步把上面的例子整理出来： 1234567891011121314154 2 1 5 3=&gt; 记录2=&gt; 比较4、记录的2 满足循环条件 赋值 =&gt; 4 4 1 5 3=&gt; 循环结束，把记录的2放在指定位置 =&gt; 2 4 1 5 3=&gt; 记录1=&gt; 比较4、记录的1 满足循环条件 赋值 =&gt; 2 4 4 5 3=&gt; 循环继续，比较2、记录的1 满足循环条件 赋值 2 2 4 5 3=&gt; 循环结束，把记录的1放在指定位置 =&gt; 1 2 4 5 3=&gt; 记录5=&gt; 比较4、记录的5，循环直接结束，把记录的5放在指定位置，也就是原位置 =&gt; 1 2 4 5 3=&gt; 记录3=&gt; 比较5、记录的3 满足循环条件 赋值 =&gt; 1 2 4 5 5=&gt; 循环继续，比较4、记录的3 满足循环条件 赋值 =&gt; 1 2 4 4 5=&gt; 循环结束，把记录的3放在指定位置 =&gt; 1 2 3 4 5结束 这里顺便提一下，谷歌浏览器V8引擎，对Array.prototype.sort()的实现用到的就是插入排序和快速排序。当数组元素小于等于22时，使用插入排序，大于22时，使用快速排序，这个有兴趣的话，可以看看V8的代码，GitHub上能搜到。火狐浏览器用的是归并排序。","categories":[{"name":"算法","slug":"算法","permalink":"https://github.com/beat-the-buzzer/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://github.com/beat-the-buzzer/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"宽松相等和严格相等","slug":"strict-loose-equality","date":"2019-12-01T16:00:00.000Z","updated":"2023-12-06T15:25:19.248Z","comments":true,"path":"2019/12/02/strict-loose-equality/","link":"","permalink":"https://github.com/beat-the-buzzer/2019/12/02/strict-loose-equality/","excerpt":"","text":"这篇文章有一个Vue标签，是因为做了一个Vue相关的项目，列举了几乎所有宽松相等和严格相等的情况，项目地址：https://github.com/beat-the-buzzer/vue-equality-table.git 提出问题宽松相等（loose equals） == 和严格相等（strict equals）=== 一直困扰着众多开发者。和Java这样的语言不同，JavaScript更加自由，但是自由的代价就是容易出错。下面就来深入研究一下宽松相等和严格相等。 误解：== 检查值是否相等，=== 除了检查值之外，还检查了类型是否相同。 听起来好像很有道理，但是，上面的说法并不准确。 正解：== 允许在比较的过程中进行强制类型转换， === 不允许。 ESLint中有一个规则： Use === and !== instead of == and !=. This avoids type coercion errors. 这就是所谓的“严师出高徒”。严格相等可以避免一些意外的错误，下面我们来踩一下宽松相等带来的坑。 类型相同的情况类型相同，就好办了，我们只需要比较两边的值是否相等就行了，例如： 12110 == 110;'abc' == 'abc'; 这里有一些特殊情况： 123NaN == NaN; // false+0 == -0; // true&#123;&#125; == &#123;&#125;; // false JavaScript中，对象是引用类型，所以，两个对象字面量分别属于两个不同的存储空间，所以是不相等的。 类型不同，强制转换string VS number123var a = '45';var b = 45;a == b; // true 其实这个是我们经常会遇到的情况，尤其是在前后端交互的时候。有时候，后台人员自己也不知道什么时候就把数字转成字符串了。规范中，这种情况的比较是把字符串转成了数字，类似于： 1Number(a) == b boolean VS others == 最容易出现错误的地方就是和布尔类型的值进行相等比较 123var a = '45';var b = true;a == b; // false 我们知道，’45’是个真值，但是’45’却不等于true。 从规范上说，如果布尔类型和其他类型比较，就需要把布尔类型转成数字类型，类似于 12a == Boolean(b);=&gt; '45' == 1 // false 但是，为什么说这个容易出错呢？那是因为我们经常写这样的代码： 123if(a) &#123; console.log('a是真值');&#125; 我们受这样的代码的影响，自然而然地认为’45’ == true 成立。事实上，上面的代码应该写成这样： 123if(Boolean(a)) &#123; console.log('a是真值');&#125; 知识的学习最后都需要去实践，根据上面说的，我们在平时写代码的时候，就需要自己格外注意： 123456789101112131415161718192021var a = '45';// 错误的示范if(a == true) &#123; // do something&#125;// 也是错误的示范if(a === true) &#123; // do something&#125;// 可以这么写if(a) &#123; // do something&#125;// 优化写法1if(Boolean(a)) &#123; // do something&#125;// 优化写法2if(!!a) &#123; // do something&#125; 为了减少出错的概率，我们在平时写代码的时候，坚决不要写类似 a == true 这样的代码。 null &amp; undefinednull 和 undefined 都是假值，它们存在这样的关系： 1null == undefined // true 我们知道，还有其他的假值，false、’’、0，这些值和null、undefined有什么关系呢？ 答案是没有什么关系，null和undefined互相相等或者与其本身相等。 12null == false // falseundefined == 0 // false object VS others对象和基本类型的比较，都是把对象转成基本类型。例如： 1[45] == 45 首先，[45]调用valueOf方法，得到的结果还是[45]，不是基本类型，然后调用了toString方法，得到了”45”，然后就把问题转化成了”45” == 45 来看一个问题，这个问题在开发中几乎不会出现，只是为了加深理解： [1] == 0 在什么情况下成立？ 根据上面的结论，我们重写valueOf方法就行了： 12345Array.prototype.valueOf = function() &#123; return 0;&#125;[1] == 0; // true 这就是传说中的指鹿为马！ 特殊情况 ‘’ == 0 上面这种情况，其实之前也说到了，我们要弄清楚被转换的是哪一个。我们都知道，’0’ == 0是成立的，但是，’’ == 0也成立，这就有点颠覆了认知。但是，我们只需要明白一点，就是： 字符串和数字的相等比较，要把字符串转换成数字。Number(‘’)的结果是0 [] == ![] 这个更加颠覆认知了，似乎这个值既是真值又是假值。 我们还是一步一步来： 12345[] == ![]&lt;=&gt; [] == false&lt;=&gt; [] == 0&lt;=&gt; '0' == 0&lt;=&gt; 0 == 0（显然成立） 这样，我们就得到了 [] == ![] 为 true的结论。 DemoGitHub用户dorey制作了几个图表，其中包括了各种 == === 和 if()的值。我自己使用了Vue-cli把项目重构了一遍，希望能有所收获。 项目运行截图： 相信看到这里，第一张图片里面，派大星的问题应该可以轻松解决了。 项目演示地址： https://beat-the-buzzer.github.io/vue-equality-table/#/","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://github.com/beat-the-buzzer/tags/Vue/"}]},{"title":"函数式编程","slug":"functional-programming","date":"2019-11-30T16:00:00.000Z","updated":"2023-12-06T15:25:19.244Z","comments":true,"path":"2019/12/01/functional-programming/","link":"","permalink":"https://github.com/beat-the-buzzer/2019/12/01/functional-programming/","excerpt":"","text":"Git地址： https://github.com/beat-the-buzzer/functional-programming.git 抛砖引玉从一道容易出错的题开始： 1['1', '2', '3'].map(parseInt); 看到这样的代码，我们就能瞬间理解代码这样写的意图，就是把数组中的所有元素都调用parseInt方法，输出一个纯数字的数组。但是我们在控制台上打印出来的结果，和预期不符： 1[1, NaN, NaN] 造成这种情况的原因是，我们想当然地认为了map方法是让数组的值都执行一次map传入的函数，所以，我们的思路是这样的： 123parseInt('1');parseInt('2');parseInt('3'); 但事实上，map方法给处理函数传的参数有三个，分别是value,index，array，另外，parseInt这个方法可以接受的参数有两个，第一个是待转换的字符串，第二个是进制。因此，上面的语句转换一下，就是这样： 1['1','2','3'].map((value,index,arr) =&gt; parseInt(value,index,arr)); 所以，我们实际上调用了这样的方法： 123parseInt('1',0);parseInt('2',1);parseInt('3',2); parseInt第二个参数是0的时候，表示按十进制转换；parseInt第二个参数是1的时候，没听说过一进制，所以是NaN；parseInt第二个参数是2的时候，表示按二进制转换，但是很遗憾，二进制的世界里只有0和1，没有3，如果我们把数组的最后一个元素改成字符串’11’，转换之后，就会得到3； 所以最开始的问题，得到了[1, NaN, NaN]的结果。 正确的打开方式是这样： 123['1','2','3'].map((value) =&gt; &#123; return parseInt(value);&#125;); 我们使用下面的方法，也就是函数式编程的思想： 1const unary = (fn) =&gt; fn.length === 1 ? fn : (arg) =&gt; fn(arg) 这是一个函数，它的参数是另一个函数，我们检查传入的函数的参数列表，如果传入的函数只有一个参数，那么就不做处理，如果有多个参数，那么就把这个函数转换成接收一个参数的函数。因此： 1['1','2','3'].map(unary(parseInt)); 就能得到[1, 2, 3]的结果了。 《JavaScript ES6函数式编程入门经典》，文中的所有内容都来自于这本书。其实，我研究一下函数式编程，有两个原因，一个是这是我的知识盲点，虽然偶尔听到过类似“函数式编程、柯里化”等术语，但是我依旧没有好好地学习这方面的知识；另一个原因是在学习Redux的时候，里面有一个connect函数，这是一个高阶函数，但是redux里面的源码我看不懂，所以我想先充实一下自己的知识，然后再去学习更深层次的东西。 什么是函数式编程言归正传，高阶函数是接受函数作为参数并且/或者返回函数作为输出的函数。 函数式编程的核心思想是：把操作抽象为函数。 举个例子：我们要遍历数组，最初级的方式是什么，我们不经过大脑也能写出来： 1234var array = [1, 2, 3];for(var i = 0; i &lt; array.length; i++) &#123; console.log(array[i]);&#125; 我们需要把遍历的操作抽象出来： 123456const forEach = (array, fn) =&gt; &#123; let i; for(i = 0; i &lt; array.length; i++) &#123; fn(array[i]); &#125;&#125; 柯里化和偏函数应用术语介绍 一元函数——只接受一个参数的函数 二元函数——接受两个参数的函数 变参函数——接受可变数量参数的函数 1234567const variadic = (a,...variadic) =&gt; &#123; console.log(a); console.log(variadic);&#125;variadic(1,2,3);// 1// [2,3] 柯里化柯里化其实并不是什么太复杂的概念，只是因为我们对它陌生罢了。 柯里化是把一个多参数函数转换为一个嵌套的一元函数的过程。 例如： 12const add = (x,y) =&gt; x + y;const addCurried = x =&gt; y =&gt; x + y; 我们可以这样调用函数： 1addCurried(4)(4); // 8 我们用es5写一个柯里化函数，这样可以更好地看到嵌套的效果： 1234567891011// 这个函数名看起来好眼熟啊！const curry = (binaryFn) =&gt; &#123; return function(firstArg) &#123; return function(secondArg) &#123; return binaryFn(firstArg,secondArg); &#125; &#125;&#125;let autoCurriedAdd = curry(add);autoCurriedAdd(2)(2); // 4 为什么需要柯里化？实际上，平时工作中很少用到柯里化函数，但是，柯里化和“闭包、arguments、apply、call、bind”有很强的联系。比起运用柯里化，我们更需要注意的是在学习柯里化的过程中强化我们的基础知识。 123456789101112131415const curry = (fn) =&gt; &#123; if (typeof fn !== 'function') &#123; throw Error('No function Provided'); &#125; return function curriedFn(...args) &#123; if (args.length &lt; fn.length) &#123; return function() &#123; return curriedFn.apply(null,args.concat( [].slice.call(arguments) )) &#125; &#125;; return fn.apply(null,args); &#125;;&#125;; 使用curry函数包裹我们需要调用的函数，就可以完成柯里化了： 1const add = (a, b, c) =&gt; a + b + c; 正常调用方式是： 1add(1, 2, 3); 柯里化的调用方式是： 12curry(add)(1)(2)(3);curry(add)(1)(2,3); 很遗憾，上面的柯里化调用方法只能处理三个参数，因为我们的add函数有三个参数。我试图写一个可变参数的add函数： 1const add = (...args) =&gt; args.reduce((x, y) =&gt; x + y); 但是，这个函数不能使用上面的柯里化方法，原因是，这个函数的length值始终是0。 偏函数应用 Partial Application(偏函数应用) 是指使用一个函数并将其应用一个或多个参数，但不是全部参数，在这个过程中创建一个新函数。 我们可以通过bind来实现这个效果： 12345function add3(a, b, c) &#123; return a + b + c; &#125; add3(2, 4, 8); // 14var add6 = add3.bind(this, 2, 4); add6(8); // 14 上面这个例子中，我们定义了add6这个函数，这个函数是add3固定了两个参数之后生成的，add6只接受一个参数，并且计算的结果是给add6的参数加上6。 如果你已经有了 curry() ，那么意味着你也已经有偏函数应用！ 12var add6 = curry(add3)(2)(4); add6(8); // 14 更新add方法： 我在书上看到了一个add方法，可以计算出任意参数的add 1234add(1,2,3,4);add(1)(2)(3)(4);add(1,2)(3,4);add(1,2,3)(4); 代码如下：https://github.com/beat-the-buzzer/functional-programming/blob/master/add.js add方法必须返回一个函数，但是我们的目标是计算累加值，所以使用了重写toString的方式，来计算累加值。 123456789101112131415161718192021222324function add() &#123; var args = [].slice.call(arguments); var adder = function() &#123; // 将参数用闭包捕获 args var adder_temp = function() &#123; args.push(...arguments); return adder_temp; &#125;; adder_temp.toString = function() &#123; return args.reduce(function(a, b) &#123; return a + b; &#125;); &#125; return adder_temp; &#125; return adder(...args);&#125;var a = add(1, 2, 3, 4);var b = add(1)(2)(3)(4);var c = add(1, 2)(3, 4);console.log(+a); // 10console.log(b.toString()); // 10console.log(`$&#123;c&#125;`); // 10 应用Demo——处理请求返回下面来实现一个高阶函数，这是我平时工作的时候遇到的一个新需求。 看下面这段代码，是我们项目中已有的调用接口的方式，我们在调用接口的时候，需要在我们自己的业务模块里面处理数据，例如，把GRID0的每一项进行分割。 12345678910111213141516171819function getData(onSend, success, error, other) &#123; var res = &#123; data: &#123; success: true, msg: '假设返回的数据', GRID0: [ '123|456|789', 'abc|def|ghi' ], KEY1INDEX: 0, KEY2INDEX: 1, KEY3INDEX: 2 &#125; &#125;; success(res);&#125;getData(&#123;&#125;, function(data) &#123; // 处理数据&#125;); 现在我们要把处理数据的代码写在公共的部分，也就是说，在调用接口的时候，成功的回调里面直接就能拿到处理后的数据。我觉得这样的需求，很适合用高阶函数。我们的目标是：HOFgetData(getData)这个函数，第二个参数是个回调函数，我们要让这个回调函数的参数变成我们想要的数据格式。下面我将一一实现。 1、我们定义的HOFgetData传入一个函数，返回一个新的函数： 1234567function HOFgetData () &#123; var args = [].slice.call(arguments); var newFunc = function (obj, success) &#123; args[0].call(null, obj, success); &#125; return newFunc;&#125; 这段代码，就是实现不做任何操作的高阶函数。 2、我们要对成功的回调函数进行处理，说具体点，就是成功的回调函数的参数。所以，我又写了一个高阶函数，来处理成功的回调函数，使得hofsuccess(success)的参数是我们需要的数据格式。 hofsuccess也是传入一个函数，返回一个新函数： 123456789101112131415161718192021var hofsuccess = function () &#123; var tempFunc = [].slice.call(arguments); // 传入的success函数 return function () &#123; var temp = [].slice.call(arguments); // 得到success的参数，就是返回值 var data = temp[0].data; // 处理数组GRID0 var LIST0 = data.GRID0.map(value =&gt; &#123; var item = value.split('|'); return &#123; KEY1: item[data.KEY1INDEX], KEY2: item[data.KEY2INDEX], KEY3: item[data.KEY3INDEX] &#125; &#125;); var obj = &#123; LIST0: LIST0, msg: data.msg &#125;; tempFunc[0](obj); &#125;&#125;; 3、HOFgetData里面取调用新的成功的回调： 123var newFunc = function (obj, success) &#123; args[0].call(null, obj, hofsuccess(success));&#125; 4、调用新的函数 12345678910111213var obj = &#123; param: 'param'&#125;;/** 高阶函数赋值，得到的newGetData是个函数，并且这个函数的参数个getData一样* 这里第二个参数在HOFgetData内部做了高阶函数处理，使得返回的结果是处理后的数据结构*/var newGetData = HOFgetData(getData);newGetData(obj, function (data) &#123; console.log(data);&#125;); 返回的结果是： 123456789101112&#123; LIST0: [&#123; KEY1: \"123\", KEY2: \"456\", KEY3: \"789\" &#125;, &#123; KEY1: \"abc\", KEY2: \"def\", KEY3: \"ghi\" &#125;], msg: \"假设返回的数据\"&#125; 点击查看完整代码整合 得到的newGetData就是我们想要的新的调用函数的方法，并且，这个方法对原有的功能不会造成影响。 应用Demo——缓存效果下面还有一个高阶函数的应用，可以应用在平时的工作中。 经常会有这样的业务场景：查询某一天的历史数据。下面，我将实现一个缓存效果，曾经访问过的值暂时缓存起来。当然，不是使用localStorage或者sessionStorage，而是高阶函数的方式。 12345678910111213141516171819202122232425262728var data = 0; // 模拟数据function postData(date) &#123; // ... 省略逻辑 console.log('发送请求，得到数据'); var result = (++data) + ':' + date; // 模拟数据 return result;&#125;// 定义的高阶函数，传入的参数是一个函数，返回一个新的函数function superPostData(fn) &#123; var cache = &#123;&#125;; // 缓存的对象 return function() &#123; var args = [].slice.call(arguments); var cachedItem = cache[args[0]]; if(cachedItem) &#123; console.log('从缓存中取数据'); return cachedItem; &#125; else &#123; cache[args[0]] = fn.apply(fn, args); // 缓存结果 return cache[args[0]]; &#125; &#125;&#125;var newPostData = superPostData(postData); // 使用高阶函数，产生一个新的函数newPostData('20190101'); // 发送请求，得到数据newPostData('20190102'); // 发送请求，得到数据newPostData('20190101'); // 从缓存中取数据 点击查看完整代码整合 从例子中，我们可以看到，第一次查询20190101的数据，缓存里没有，于是调用接口，得到数据并缓存；然后，查询20190102的数据，缓存里也没有，于是调用接口，得到数据并缓存。当我们再次查询20190101的数据，发现缓存里有这条数据，于是直接取出来，这样就减少了http请求，提升了性能。 以上就是我想要讲的关于函数式编程的所有内容，如果能弄懂上面的add函数，相信你会对函数、闭包这一类的概念有了更深的理解。建议大家在以后学习React的时候，试着去写一些高阶组件，相信不会太难理解。 其他应用： 防抖节流操作总结","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://github.com/beat-the-buzzer/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"Markdown语法总结","slug":"markdown","date":"2019-11-29T16:00:00.000Z","updated":"2023-12-06T15:25:19.246Z","comments":true,"path":"2019/11/30/markdown/","link":"","permalink":"https://github.com/beat-the-buzzer/2019/11/30/markdown/","excerpt":"","text":"Markdown简介Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 我们在使用Word工具传文档时，经常会出现版本兼容问题，除了Word的版本之外，还有的人使用的是WPS，另外，Mac和Windows之间也有兼容问题。 Markdown里面的文本转出来之后，本质上是HTML，所以几乎可以解决所有的兼容问题。 编辑工具VSCode：一般我们的代码里面都有一个说明文档，叫做README.md。我们在编辑代码的同时，也可以去编辑md文件。不过，如果我们想要去看效果的话，还需要下载一个插件——Markdown Preview Enhanced。插件文档中，有打开预览的快捷键，也可以右键打开预览。 Markdown Pad：一个所见即所得的Markdown编辑工具，提供导出HTML或者PDF的操作。 基本语法简介1234567891011链接: [Title](URL)加粗: **Bold**斜体字: *Italics*删除线：~~你制杖吗~~列表: * 或者 - 添加星号成为一个新的列表项引用: &gt; 引用内容内嵌代码: &#96;alert(&#39;Hello World&#39;);&#96;画水平线 (HR) : --------选择方框: - [ ]选中的方框: - [x]图片: ![defaultText](URL) 点击跳转 加粗的文字 倾斜的文字 你制杖吗 列表方式1 列表方式2 走自己的路，让别人说去吧！ 不要在代码里面写if(a == true) 这是一个选项 这是一个选中的选项 其他语法简介1、代码块 使用``` ```包裹，可以指定语言类型，例如： 123var arr = [1, 2, 3];arr.push(4);console.log(arr); 12345public class HellWorld &#123; public static void main(String[] args) &#123; System.out.print('Hello World'); &#125;&#125;123var arr = [1, 2, 3];arr.push(4);console.log(arr); 12345public class HellWorld &#123; public static void main(String[] args) &#123; System.out.print('Hello World'); &#125;&#125; 2、表格 name | 111 | 222 | 333 | 444 :-: | :-: | :-: | :-: | :-: aaa | bbb | ccc | ddd | eee| fff | ggg | hhh | iii | 000| aaa | bbb | ccc | ddd | eee| fff | ggg | hhh | iii | 000| name 111 222 333 444 aaaaaa bbb ccc ddd eee ffffff ggg hhh iii 000 aaaaaa bbb ccc ddd eee ffffff ggg hhh iii 000 3、目录 只需要在单行写上：[TOC]，不区分大小写，就可以自动出现目录了。这个目录就是文档里使用#的标题。 [toc] 总结： 以上就是Markdown大部分常用语法，这些足够我们在项目中写一篇好的README了。多写多总结，持续进步。","categories":[{"name":"其他","slug":"其他","permalink":"https://github.com/beat-the-buzzer/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://github.com/beat-the-buzzer/tags/MarkDown/"}]},{"title":"Git基本用法总结","slug":"git","date":"2019-11-28T16:00:00.000Z","updated":"2023-12-06T15:25:19.244Z","comments":true,"path":"2019/11/29/git/","link":"","permalink":"https://github.com/beat-the-buzzer/2019/11/29/git/","excerpt":"","text":"用户配置查看当前配置的用户名和邮箱： 12git config user.namegit config user.email 配置用户名和邮箱： 12git config --global user.name 'name'git config --global user.email 'email' 密码操作： 1git config --global credential.helper store 新建操作新建分支的操作： 123456git branch [mybranch] 创建本地分支git checkout [mybranch] 切换本地分支git checkout -b [mybranch] 创建并切换分支git checkout -b [mybranch] origin/[分支名] 从之前的某个分支里拉一个分支出来，也就是说，这里复制了某个分支的代码git push origin [mybranch] 本地推送到远程（同时创建了远程分支）git subtree push --prefix=dist origin gh-pages 将文件前缀为dist的文件夹内容推送到gh-pages远程 查看操作查看当前文件状态： 1git status 查看本地分支： 1git branch 查看远程分支： 1git branch -a 查看远程地址： 1git remote -v 提交代码12345git add [文件名]git reset HEAD // 撤销上次addgit commit -m '[提交日志]'git reset --soft HEAD^ // 撤销上次提交git push 分支合并的操作1git merge [test] (至当前分支) 分支合并之前的操作：保证test分支是最新的，切换到test分支， 123git checkout [test] 切换到test分支git fetch 获取更新（一般的图形工具都会有自动fetch的功能）git pull 拉取代码 然后切换到当前分支，合并test至当前分支。 版本回退的操作123git log 找到需要回退到这个版本的commit IDgit reset --hard [commit id]git push -f -u origin [branchname] 最好不要在需要回退的版本上直接操作，应该先在那个分支上面拉一个分支，然后在分支上进行操作。 删除分支的操作12git push origin --delete [mybranch] // 删除远程分支git branch -d [mybranch] // 删除本地分支","categories":[{"name":"其他","slug":"其他","permalink":"https://github.com/beat-the-buzzer/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://github.com/beat-the-buzzer/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://github.com/beat-the-buzzer/tags/GitHub/"}]},{"title":"ESLint配置教程（VSCode插件版）","slug":"eslint","date":"2019-11-27T16:00:00.000Z","updated":"2023-12-06T15:25:19.244Z","comments":true,"path":"2019/11/28/eslint/","link":"","permalink":"https://github.com/beat-the-buzzer/2019/11/28/eslint/","excerpt":"","text":"Git项目地址：https://github.com/beat-the-buzzer/eslint-test.git ESLint简介ESLint 是一个ECMAScript/JavaScript 语法规则和代码风格的检查工具，它的目标是保证代码的一致性和减少错误。 JavaScript 是一个动态的弱类型语言，在开发中比较容易出错。因为没有编译程序，为了寻找 JavaScript 代码错误通常需要在执行过程中不断调试。像 ESLint 这样的可以让程序员在编码的过程中发现问题而不是在执行的过程中。 使用ESLint，有时候编辑器会强制我们去使用ES6，这样有助于我们对ES6的学习。 使用ESLint，不仅仅是为了写更加规范的代码，更重要的原因是，编辑器指出了代码中不规范的地方，我们可以从中学会如何去写规范的代码，最终目标是在没有ESLint的时候也能写出规范的代码。 ESLint的配置我们知道vue-cli集成了webpack，其中我们可以选择是否使用ESLint。不过vue-cli里面自带的ESLint有一些不方便的地方，就是一旦出现不符合规范的代码，就会直接编译报错，页面上打印了错误信息。但是有时候，我们在开发阶段，临时写了一些不规范的代码，此时如果ESLint提示出错，就会很困扰。 我们可以使用VSCode里面的ESLint插件，这样，我们就会在VSCode底部的“问题控制台”看到报错信息，但是不影响项目的运行。 配置步骤先使用npm/yarn安装一些东西123456789101112npm install -g eslint # 全局安装eslintnpm init -y # 调过设置，生成package.jsoneslint --init # 跟着提示一步步走，中间会让你安装对应的模块### 下面是一些配置# 1. How do you like to use ESLint? To check syntax, find problems, and enforce code style# 2. What type of modules dose your project use? 根据项目需要去选择# Which framework does your project use? 根据项目需要去选择，这个选择体现在后面安装模块上# Where does your code run? 一般选择browser# How would you like to define a style for your project? Use a popular style guide.# Which style guide do you want to follow? 推荐使用Airbnb# What format do you want your config file to be in? Javascript### 上面选择完成之后，就会去安装相关的模块 安装VSCode的ESLint插件这个在VSCode左边搜索一下就能找到了 配置文件先激活上面下载的ESLint插件 点击VSCode的设置，然后在设置里面搜索ESLint，就能看到很多关于ESLint的设置。 这里可以选择“用户设置”和“工作区设置”，“用户设置”可以理解为VSCode打开的项目都会使用这个设置，“工作区设置”，这里面的设置只会影响单个项目。在“工作区设置”里面进行个性化设置的时候，会在项目目录下生成一个.vscode文件夹。 在工作区设置里面，点击在settings.json中编辑，会进入.vscode/settings.json文件。 在这个文件里面设置ESLint配置文件目录 12345&#123; \"eslint.options\": &#123; \"configFile\": \"./.eslintrc.js\" &#125;&#125; 经过上面的步骤，我们就可以使用ESLint来优化代码了。 定义规则我们写一段最简单的代码： 12var num = 1;console.log(num); 此时编辑器会有一些报错信息或者警告： 12Unexpected var, use let or const instead.Unexpected console statement. 根据提示，我们需要把var改成const，因为num没有进行过第二次赋值， ESLint的默认规则，当使用console的时候，会报警告，但是我们在开发阶段需要console，此时我们需要把这个规则关掉，我们需要去编辑.eslintrc.js文件的rules。 1'no-console': 0 前面的是规则名，后面的值是数字，0表示不启用这个规则，1表示warn，2表示error。","categories":[{"name":"其他","slug":"其他","permalink":"https://github.com/beat-the-buzzer/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"ESLint","slug":"ESLint","permalink":"https://github.com/beat-the-buzzer/tags/ESLint/"},{"name":"VSCode","slug":"VSCode","permalink":"https://github.com/beat-the-buzzer/tags/VSCode/"}]},{"title":"CSS3 动画","slug":"c3-animation","date":"2019-11-26T16:00:00.000Z","updated":"2023-12-06T15:25:19.243Z","comments":true,"path":"2019/11/27/c3-animation/","link":"","permalink":"https://github.com/beat-the-buzzer/2019/11/27/c3-animation/","excerpt":"","text":"项目Git地址：https://github.com/beat-the-buzzer/c3-animation.git 什么是动画1、动画片、漫画、视频、flash等等，会动的画面都是动画 2、颜色高度等属性的变化（过渡）也是动画 3、CSS3对于动画的实现由过渡和帧动画 初识CSS3动画1、CSS3动画包括transition和animation 2、动画常常和transform属性配合使用 3、transform不是动画属性 CSS3动画的兼容性 CSS3动画效果兼容 1、IE10 2012-09-04 开始兼容动画 2、Chrome 4 2010-01-25 -webkit 3、Firefox 5 2011-01-25 CSS3事件兼容 1、IE 10 2013-10-17 2、Chrome 4 2010-01-25 3、Firefox 5 2011-01-25 CSS3动画的应用1、功能性的菜单按钮 2、宣传用的轮播图、页面效果的缓冲 3、页面的切换过渡、小游戏 CSS3动画的学习目标1、熟练使用transition和animation 2、熟练使用动画库，观察动画，得到更好的实现方案 3、复杂动画的开发和实现 transition的使用Transition基础1、属性名称（property） 2、过渡时间（duration）和延迟时间（delay） 3、时间函数（timing-function） 1234567891011121314.box &#123; width: 100px; height: 100px; background: #000;&#125;.demo-1 &#123; /* 属性名 过渡时间 时间函数 延时*/ /* 时间函数 linear ease */ /* 鼠标放在元素上延时两秒后，宽度匀速从100px增长到500px */ transition: width 2s linear 2s;&#125;.demo-1:hover &#123; width: 500px;&#125; 上面的例子中，矩形宽度平缓增长，看起来有一点卡顿，我们可以去修改时间函数。实际上，linear和easa都是贝塞尔曲线（cubic-bezier）的特殊情况，我们可以在控制台上去调试运动的曲线，从而达到我们想要的运动，如下图所示： 我们可以点击控制台上的时间函数： 我们可以调整运动曲线，得到bezier属性值： 注意事项1、display: none;不能和transition一起使用 transition需要读取元素的初始属性值，display为none的情况下，很多属性都读不到 2、transition后面尽量不要跟all transition需要去检查元素属性的变化，如果使用all，就会把所有的属性都去检查一遍，造成大量资源的浪费 3、解决闪动问题，使用3D属性 perspective、backface-visibility、translate3d(0,0,0) animation的使用Animation基础1、动画名称（name）–@keyframes 2、过渡时间（duration）和延迟时间（delay） 3、时间函数（timing-function） 1234567891011121314151617181920.box &#123; width: 100px; height: 100px; background: #000;&#125;.demo-1 .cell &#123; width: 200px; height: 200px; background: red;&#125;.demo-1:hover .cell&#123; animation: move 2s linear;&#125;@keyframes move&#123; 100% &#123; transform: translateX(200px); &#125;&#125; 4、播放次数（iteration-count） 5、播放方向（direction），是否轮流播放和反向播放 6、停止播放的状态（fill-mode），是否暂停（play-state） 注意事项：1、解决了transition和display:none的冲突问题 2、实现跳动的元素 Demo——自由落体下面是一个Demo，实现物体的自由落体运动。 自由落体运动的关键在于时间函数，选择合适的时间函数会让物体运动得更加逼真。 首先，我观察了一下系统自带的时间函数： linear：动画从头到尾的速度是相同的 linear效果 ease：默认。动画以低速开始，然后加快，在结束前变慢 ease效果 ease-in: 动画以低速开始 ease-in效果 ease-out: 动画以低速结束 ease-out效果 ease-in-out: 动画以低速开始和结束 ease-in-out效果 观察这些轨迹，我发现，贝塞尔曲线最终就是物体的位移轨迹，我们可以通过修改控制点的方式来修改位移。 显然，自由落体运动是初速度为0，加速度为g的匀加速直线运动，所以最终的位移曲线应该是一个定点在原点，开口向上的抛物线。 大致在浏览器上画了一个差不多的曲线，值得注意的是，由于自由落体的初速度为0，初始位置的切线必然和x轴平行，得到了贝塞尔曲线的函数方程： 最终运行效果： 点击查看运行效果 Demo——红包雨效果点击查看项目源码 点击查询红包雨效果","categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://github.com/beat-the-buzzer/tags/CSS/"},{"name":"CSS3","slug":"CSS3","permalink":"https://github.com/beat-the-buzzer/tags/CSS3/"},{"name":"动画","slug":"动画","permalink":"https://github.com/beat-the-buzzer/tags/%E5%8A%A8%E7%94%BB/"}]}],"categories":[{"name":"前端开发","slug":"前端开发","permalink":"https://github.com/beat-the-buzzer/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"技术方案","slug":"技术方案","permalink":"https://github.com/beat-the-buzzer/categories/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"},{"name":"疑难问题","slug":"疑难问题","permalink":"https://github.com/beat-the-buzzer/categories/%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/"},{"name":"定律","slug":"定律","permalink":"https://github.com/beat-the-buzzer/categories/%E5%AE%9A%E5%BE%8B/"},{"name":"通信","slug":"通信","permalink":"https://github.com/beat-the-buzzer/categories/%E9%80%9A%E4%BF%A1/"},{"name":"其他","slug":"其他","permalink":"https://github.com/beat-the-buzzer/categories/%E5%85%B6%E4%BB%96/"},{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/categories/%E9%9D%A2%E8%AF%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://github.com/beat-the-buzzer/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"工程化","slug":"工程化","permalink":"https://github.com/beat-the-buzzer/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"生活感悟","slug":"生活感悟","permalink":"https://github.com/beat-the-buzzer/categories/%E7%94%9F%E6%B4%BB%E6%84%9F%E6%82%9F/"},{"name":"算法","slug":"算法","permalink":"https://github.com/beat-the-buzzer/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"工程化","slug":"工程化","permalink":"https://github.com/beat-the-buzzer/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://github.com/beat-the-buzzer/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://github.com/beat-the-buzzer/tags/JavaScript/"},{"name":"提效","slug":"提效","permalink":"https://github.com/beat-the-buzzer/tags/%E6%8F%90%E6%95%88/"},{"name":"疑难问题","slug":"疑难问题","permalink":"https://github.com/beat-the-buzzer/tags/%E7%96%91%E9%9A%BE%E9%97%AE%E9%A2%98/"},{"name":"视频","slug":"视频","permalink":"https://github.com/beat-the-buzzer/tags/%E8%A7%86%E9%A2%91/"},{"name":"心理学","slug":"心理学","permalink":"https://github.com/beat-the-buzzer/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"认知","slug":"认知","permalink":"https://github.com/beat-the-buzzer/tags/%E8%AE%A4%E7%9F%A5/"},{"name":"网络","slug":"网络","permalink":"https://github.com/beat-the-buzzer/tags/%E7%BD%91%E7%BB%9C/"},{"name":"Git","slug":"Git","permalink":"https://github.com/beat-the-buzzer/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://github.com/beat-the-buzzer/tags/GitHub/"},{"name":"浏览器","slug":"浏览器","permalink":"https://github.com/beat-the-buzzer/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"通信","slug":"通信","permalink":"https://github.com/beat-the-buzzer/tags/%E9%80%9A%E4%BF%A1/"},{"name":"VSCode","slug":"VSCode","permalink":"https://github.com/beat-the-buzzer/tags/VSCode/"},{"name":"面试","slug":"面试","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95/"},{"name":"http","slug":"http","permalink":"https://github.com/beat-the-buzzer/tags/http/"},{"name":"webpack","slug":"webpack","permalink":"https://github.com/beat-the-buzzer/tags/webpack/"},{"name":"CSS","slug":"CSS","permalink":"https://github.com/beat-the-buzzer/tags/CSS/"},{"name":"函数式编程","slug":"函数式编程","permalink":"https://github.com/beat-the-buzzer/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://github.com/beat-the-buzzer/tags/MarkDown/"},{"name":"CSS3","slug":"CSS3","permalink":"https://github.com/beat-the-buzzer/tags/CSS3/"},{"name":"移动端适配","slug":"移动端适配","permalink":"https://github.com/beat-the-buzzer/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"},{"name":"阅读","slug":"阅读","permalink":"https://github.com/beat-the-buzzer/tags/%E9%98%85%E8%AF%BB/"},{"name":"Vue","slug":"Vue","permalink":"https://github.com/beat-the-buzzer/tags/Vue/"},{"name":"感悟","slug":"感悟","permalink":"https://github.com/beat-the-buzzer/tags/%E6%84%9F%E6%82%9F/"},{"name":"gulp","slug":"gulp","permalink":"https://github.com/beat-the-buzzer/tags/gulp/"},{"name":"算法","slug":"算法","permalink":"https://github.com/beat-the-buzzer/tags/%E7%AE%97%E6%B3%95/"},{"name":"面试题","slug":"面试题","permalink":"https://github.com/beat-the-buzzer/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://github.com/beat-the-buzzer/tags/Shadowsocks/"},{"name":"ESLint","slug":"ESLint","permalink":"https://github.com/beat-the-buzzer/tags/ESLint/"},{"name":"动画","slug":"动画","permalink":"https://github.com/beat-the-buzzer/tags/%E5%8A%A8%E7%94%BB/"}]}